<div class="post-content"> <br> <p>There is a <a href="https://github.com/hmemcpy/milewski-ctfp-pdf">pdf version</a> of this book with nicer typesetting available for download.</p>
<p>You may also watch me <a href="https://www.youtube.com/playlist?list=PLbgaMIhjbmEnaH_LTkxLI7FMa2HsnawM_">teaching this material</a> to a live audience.</p> <blockquote><p>For some time now I&#x2019;ve been floating the idea of writing a book about category theory that would be targeted at programmers. Mind you, not computer scientists but programmers &#x2014; engineers rather than scientists. I know this sounds crazy and I am properly scared. I can&#x2019;t deny that there is a huge gap between science and engineering because I have worked on both sides of the divide. But I&#x2019;ve always felt a very strong compulsion to explain things. I have tremendous admiration for Richard Feynman who was the master of simple explanations. I know I&#x2019;m no Feynman, but I will try my best. I&#x2019;m starting by publishing this preface &#x2014; which is supposed to motivate the reader to learn category theory &#x2014; in hopes of starting a discussion and soliciting feedback.</p></blockquote>
<p>I will attempt, in the space of a few paragraphs, to convince you that this book is written for you, and whatever objections you might have to learning one of the most abstract branches of mathematics in your &#x201C;copious spare&#xA0;time&#x201D; are totally unfounded.</p>
<p>My optimism is based on several observations. First, category theory is a treasure trove&#xA0;of extremely useful programming ideas. Haskell programmers have been tapping this resource&#xA0;for a long time, and the ideas are slowly percolating into other languages, but this process is too slow. We need to speed it up.</p>
<p>Second, there are many different kinds of math, and they appeal to different audiences. You might be allergic to calculus or algebra, but it doesn&#x2019;t mean you won&#x2019;t enjoy category theory. I would go as far as to&#xA0;argue&#xA0;that category theory is the kind of math that is particularly well suited for the minds of programmers. That&#x2019;s because category theory &#x2014; rather than dealing with particulars &#x2014; deals with structure. It deals with the kind of structure that makes programs composable.</p>
<p>Composition is at the very root of category theory &#x2014; it&#x2019;s part of the definition of the category itself. And I will argue strongly that composition is the essence of programming. We&#x2019;ve been composing things forever, long before some great engineer came up with the idea of a subroutine. Some time ago the principles of structural programming revolutionized programming&#xA0;because they made blocks of code composable. Then came object oriented programming, which is all about composing objects. Functional programming is not only about composing functions and algebraic data structures &#x2014; it makes concurrency composable &#x2014; something that&#x2019;s virtually impossible with other programming paradigms.</p>
<p>Third, I have a secret weapon, a butcher&#x2019;s knife, with which I will butcher math to make it more palatable to programmers. When you&#x2019;re a professional mathematician, you have to be very careful to get all your assumptions straight, qualify every statement properly, and construct all your proofs rigorously. This makes mathematical papers and books extremely hard to read for an outsider. I&#x2019;m a physicist by training, and in physics we made amazing advances using informal reasoning. Mathematicians laughed at the Dirac delta function, which was made up on the spot by the great physicist P. A. M. Dirac to solve some differential equations. They stopped laughing when they discovered a completely new branch of calculus called distribution theory that formalized Dirac&#x2019;s insights.</p>
<p>Of course when using hand-waving arguments you run the risk of saying something blatantly wrong, so I will try to make sure that there is solid mathematical theory behind informal arguments in this book. I do have a worn-out copy of Saunders Mac Lane&#x2019;s <em>Category Theory for the Working Mathematician</em> on my nightstand.</p>
<p>Since this is category theory <i>for programmers</i> I will illustrate all major concepts using computer code. You are probably aware that functional languages are closer to math than the more popular imperative languages. They also offer more abstracting power. So a natural temptation would be to say: You must learn Haskell before the bounty of category theory becomes available to you. But that would imply that category theory has no application outside of functional programming and that&#x2019;s simply not true. So I will provide a lot of C++ examples. Granted, you&#x2019;ll have to overcome some ugly syntax, the patterns might not stand out from the background of verbosity, and you might be forced to do some copy and paste in lieu of higher abstraction, but that&#x2019;s just the lot of a C++ programmer.</p>
<p>But you&#x2019;re not off the hook as far as Haskell is concerned. You don&#x2019;t have to become a Haskell programmer, but you need it as a language for sketching and documenting ideas to be implemented in C++. That&#x2019;s exactly how I got started with Haskell. I found its terse syntax and powerful type system a great help in understanding and implementing C++ templates, data structures, and algorithms. But since I can&#x2019;t expect the readers to already know Haskell, I will introduce it slowly and explain everything as I go.</p>
<p>If you&#x2019;re an experienced programmer, you might be asking yourself: I&#x2019;ve been coding for so long without worrying about category theory or functional methods, so what&#x2019;s changed? Surely you can&#x2019;t help but notice that there&#x2019;s been a steady stream of new functional features invading imperative languages. Even Java, the bastion of object-oriented programming, let the lambdas in C++ has recently been evolving at a frantic pace &#x2014; a new standard every few years &#x2014; trying to catch up with the changing world. All this activity is in preparation for a disruptive change or, as we physicist call it, a phase transition. If you keep heating water, it will eventually start boiling. We are now in the position of a frog that must decide if it should continue swimming in increasingly hot water, or start looking for some alternatives.</p>
<p><a href="https://bartoszmilewski.files.wordpress.com/2014/10/img_1299.jpg"><img class="aligncenter wp-image-3468 size-medium" src="https://bartoszmilewski.files.wordpress.com/2014/10/img_1299.jpg?w=300&amp;h=213%20300w,%20https://bartoszmilewski.files.wordpress.com/2014/10/img_1299.jpg?w=600&amp;h=426%20600w,%20https://bartoszmilewski.files.wordpress.com/2014/10/img_1299.jpg?w=150&amp;h=107%20150w" alt="IMG_1299" width="300" srcset="https://bartoszmilewski.files.wordpress.com/2014/10/img_1299.jpg?w=300&amp;h=213 300w, https://bartoszmilewski.files.wordpress.com/2014/10/img_1299.jpg?w=600&amp;h=426 600w, https://bartoszmilewski.files.wordpress.com/2014/10/img_1299.jpg?w=150&amp;h=107 150w"></a></p>
<p>One of the forces that are driving the big change is the multicore revolution. The prevailing programming paradigm, object oriented programming, doesn&#x2019;t buy you anything in the realm of concurrency and parallelism, and instead encourages dangerous and buggy design. Data hiding, the basic premise of object orientation, when combined with sharing and mutation, becomes a recipe for data races. The idea of combining a mutex with the data it protects is nice but, unfortunately, locks don&#x2019;t compose, and lock hiding makes deadlocks more likely and harder to debug.</p>
<p>But even in the absence of concurrency, the growing complexity of software systems is testing the limits of scalability of the imperative paradigm. To put it simply, side effects are getting out of hand. Granted, functions that have side effects are often convenient and easy to write. Their effects can in principle be encoded in their names and in the comments. A function called SetPassword or WriteFile is obviously mutating some state and generating side effects, and we are used to dealing with that. It&#x2019;s only when we start composing functions that have side effects on top of other functions that have side effects, and so on, that things start getting hairy. It&#x2019;s not that side effects are inherently bad &#x2014; it&#x2019;s the fact that they are hidden from view that makes them impossible to manage at larger scales. Side effects don&#x2019;t scale, and imperative programming is all about side effects.</p>
<p>Changes in hardware and the growing complexity of software are forcing us to rethink the foundations of programming. Just like the builders of Europe&#x2019;s great gothic cathedrals we&#x2019;ve been honing our craft to the limits of material and structure. There is an unfinished gothic <a href="http://en.wikipedia.org/wiki/Beauvais_Cathedral">cathedral in Beauvais</a>, France, that stands witness to this deeply human struggle with limitations. It was intended to beat all previous records of height and lightness, but it suffered a series of collapses. Ad hoc measures like iron rods and wooden supports keep it from disintegrating, but obviously a lot of things went wrong. From a modern perspective, it&#x2019;s a miracle that so many gothic structures had been successfully completed without the help of modern material science, computer modelling, finite element analysis, and general math and physics. I hope future generations will be as admiring of the programming skills we&#x2019;ve been displaying in building complex operating systems, web servers, and the internet infrastructure. And, frankly, they should, because we&#x2019;ve done all this based on very flimsy theoretical foundations. We have to fix those foundations if we want to move forward.</p>
<div id="attachment_3472" class="wp-caption aligncenter"><a href="https://bartoszmilewski.files.wordpress.com/2014/10/beauvais_interior_supports.jpg"><img class="size-medium wp-image-3472" src="https://bartoszmilewski.files.wordpress.com/2014/10/beauvais_interior_supports.jpg?w=225&amp;h=300%20225w,%20https://bartoszmilewski.files.wordpress.com/2014/10/beauvais_interior_supports.jpg?w=113&amp;h=150%20113w,%20https://bartoszmilewski.files.wordpress.com/2014/10/beauvais_interior_supports.jpg%20360w" alt="Ad hoc measures preventing the Beauvais cathedral from collapsing" width="225" srcset="https://bartoszmilewski.files.wordpress.com/2014/10/beauvais_interior_supports.jpg?w=225&amp;h=300 225w, https://bartoszmilewski.files.wordpress.com/2014/10/beauvais_interior_supports.jpg?w=113&amp;h=150 113w, https://bartoszmilewski.files.wordpress.com/2014/10/beauvais_interior_supports.jpg 360w"></a><p class="wp-caption-text">Ad hoc measures preventing the Beauvais cathedral from collapsing</p></div>
<p>Next: <a href="https://bartoszmilewski.com/2014/11/04/category-the-essence-of-composition/">Category: The Essence of Composition</a>.</p>
<a href="https://twitter.com/BartoszMilewski" class="twitter-follow-button">Follow @BartoszMilewski</a> </div>