<div class="post-content"> <br><blockquote><p>This is part 12 of Categories for Programmers. Previously: <a href="https://bartoszmilewski.com/2015/04/15/category-theory-and-declarative-programming/">Declarative Programming</a>. See the <a href="https://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/">Table of Contents</a>.</p></blockquote>
<p>It seems like in category theory everything is related to everything and everything can be viewed from many angles. Take for instance the universal construction of the <a href="https://bartoszmilewski.com/2015/01/07/products-and-coproducts/">product</a>. Now that we know more about <a href="https://bartoszmilewski.com/2015/01/20/functors/">functors</a> and <a href="https://bartoszmilewski.com/2015/04/07/natural-transformations/">natural transformations</a>, can we simplify and, possibly, generalize it? Let us try.</p>
<p><a href="https://bartoszmilewski.files.wordpress.com/2014/12/productpattern.jpg"><img class="alignnone wp-image-3767 size-thumbnail" src="https://bartoszmilewski.files.wordpress.com/2014/12/productpattern.jpg?w=150&amp;h=99%20150w,%20https://bartoszmilewski.files.wordpress.com/2014/12/productpattern.jpg?w=300&amp;h=198%20300w" alt="ProductPattern" width="150" srcset="https://bartoszmilewski.files.wordpress.com/2014/12/productpattern.jpg?w=150&amp;h=99 150w, https://bartoszmilewski.files.wordpress.com/2014/12/productpattern.jpg?w=300&amp;h=198 300w"></a></p>
<p>The construction of a product starts with the selection of two objects <code>a</code> and <code>b</code>, whose product we want to construct. But what does it mean to <em>select objects</em>? Can we rephrase this action in more categorical terms? Two objects form a pattern &#x2014; a very simple pattern. We can abstract this pattern into a category &#x2014; a very simple category, but a category nevertheless. It&#x2019;s a category that we&#x2019;ll call <strong>2</strong>. It contains just two objects, 1 and 2, and no morphisms other than the two obligatory identities. Now we can rephrase the selection of two objects in <em>C</em> as the act of defining a functor D from the category <strong>2</strong> to <em>C</em>. A functor maps objects to objects, so its image is just two objects (or it could be one, if the functor collapses objects, which is fine too). It also maps morphisms &#x2014; in this case it simply maps identity morphisms to identity morphisms.</p>
<p><a href="https://bartoszmilewski.files.wordpress.com/2015/04/two.jpg"><img class="alignnone wp-image-4482 size-medium" src="https://bartoszmilewski.files.wordpress.com/2015/04/two.jpg?w=300&amp;h=220%20300w,%20https://bartoszmilewski.files.wordpress.com/2015/04/two.jpg?w=150&amp;h=110%20150w,%20https://bartoszmilewski.files.wordpress.com/2015/04/two.jpg%20320w" alt="Two" width="300" srcset="https://bartoszmilewski.files.wordpress.com/2015/04/two.jpg?w=300&amp;h=220 300w, https://bartoszmilewski.files.wordpress.com/2015/04/two.jpg?w=150&amp;h=110 150w, https://bartoszmilewski.files.wordpress.com/2015/04/two.jpg 320w"></a></p>
<p>What&#x2019;s great about this approach is that it builds on categorical notions, eschewing the imprecise descriptions like &#x201C;selecting objects,&#x201D; taken straight from the hunter-gatherer lexicon of our ancestors. And, incidentally, it is also easily generalized, because nothing can stop us from using categories more complex than <strong>2</strong> to define our patterns.</p>
<p>But let&#x2019;s continue. The next step in the definition of a product is the selection of the candidate object <code>c</code>. Here again, we could rephrase the selection in terms of a functor from a singleton category. And indeed, if we were using Kan extensions, that would be the right thing to do. But since we are not ready for Kan extensions yet, there is another trick we can use: a constant functor &#x394; from the same category <strong>2</strong> to <em>C</em>. The selection of <code>c</code> in <em>C</em> can be done with &#x394;<sub>c</sub>. Remember, &#x394;<sub>c</sub> maps all objects into <code>c</code> and all morphisms into <code>id<sub>c</sub></code>.</p>
<p><a href="https://bartoszmilewski.files.wordpress.com/2015/04/twodelta.jpg"><img class="alignnone size-medium wp-image-4483" src="https://bartoszmilewski.files.wordpress.com/2015/04/twodelta.jpg?w=300&amp;h=212%20300w,%20https://bartoszmilewski.files.wordpress.com/2015/04/twodelta.jpg?w=150&amp;h=106%20150w,%20https://bartoszmilewski.files.wordpress.com/2015/04/twodelta.jpg%20320w" alt="TwoDelta" width="300" srcset="https://bartoszmilewski.files.wordpress.com/2015/04/twodelta.jpg?w=300&amp;h=212 300w, https://bartoszmilewski.files.wordpress.com/2015/04/twodelta.jpg?w=150&amp;h=106 150w, https://bartoszmilewski.files.wordpress.com/2015/04/twodelta.jpg 320w"></a></p>
<p>Now we have two functors, &#x394;<sub>c</sub> and D going between <strong>2</strong> and <em>C</em> so it&#x2019;s only natural to ask about natural transformations between them. Since there are only two objects in <strong>2</strong>, a natural transformation will have two components. Object 1 in <strong>2</strong> is mapped to <code>c</code> by &#x394;<sub>c</sub> and to <code>a</code> by D. So the component of a natural transformation between &#x394;<sub>c</sub> and D at 1 is a morphism from <code>c</code> to <code>a</code>. We can call it <code>p</code>. Similarly, the second component is a morphism <code>q</code> from <code>c</code> to <code>b</code> &#x2014; the image of the object 2 in <strong>2</strong> under D. But these are exactly like the two projections we used in our original definition of the product. So instead of talking about selecting objects and projections, we can just talk about picking functors and natural transformations. It so happens that in this simple case the naturality condition for our transformation is trivially satisfied, because there are no morphisms (other than the identities) in <strong>2</strong>.</p>
<p><a href="https://bartoszmilewski.files.wordpress.com/2015/04/productcone.jpg"><img class="alignnone size-medium wp-image-4498" src="https://bartoszmilewski.files.wordpress.com/2015/04/productcone.jpg?w=300&amp;h=203%20300w,%20https://bartoszmilewski.files.wordpress.com/2015/04/productcone.jpg?w=150&amp;h=102%20150w,%20https://bartoszmilewski.files.wordpress.com/2015/04/productcone.jpg%20320w" alt="ProductCone" width="300" srcset="https://bartoszmilewski.files.wordpress.com/2015/04/productcone.jpg?w=300&amp;h=203 300w, https://bartoszmilewski.files.wordpress.com/2015/04/productcone.jpg?w=150&amp;h=102 150w, https://bartoszmilewski.files.wordpress.com/2015/04/productcone.jpg 320w"></a></p>
<p>A generalization of this construction to categories other than <strong>2</strong> &#x2014; ones that, for instance, contain non-trivial morphisms &#x2014; will impose naturality conditions on the transformation between &#x394;<sub>c</sub> and D. We call such transformation a <em>cone</em>, because the image of &#x394; is the apex of a cone/pyramid whose sides are formed by the components of the natural transformation. The image of D forms the base of the cone.</p>
<p>In general, to build a cone, we start with a category <em>I</em> that defines the pattern. It&#x2019;s a small, often finite category. We pick a functor D from <em>I</em> to <em>C</em> and call it (or its image) a <em>diagram</em>. We pick some <code>c</code> in <em>C</em> as the apex of our cone. We use it to define the constant functor &#x394;<sub>c</sub> from <em>I</em> to <em>C</em>. A natural transformation from &#x394;<sub>c</sub> to D is then our cone. For a finite <em>I</em> it&#x2019;s just a bunch of morphisms connecting <code>c</code> to the diagram: the image of <em>I</em> under D.</p>
<p><a href="https://bartoszmilewski.files.wordpress.com/2015/04/cone.jpg"><img class="alignnone size-medium wp-image-4485" src="https://bartoszmilewski.files.wordpress.com/2015/04/cone.jpg?w=300&amp;h=216%20300w,%20https://bartoszmilewski.files.wordpress.com/2015/04/cone.jpg?w=150&amp;h=108%20150w,%20https://bartoszmilewski.files.wordpress.com/2015/04/cone.jpg%20320w" alt="Cone" width="300" srcset="https://bartoszmilewski.files.wordpress.com/2015/04/cone.jpg?w=300&amp;h=216 300w, https://bartoszmilewski.files.wordpress.com/2015/04/cone.jpg?w=150&amp;h=108 150w, https://bartoszmilewski.files.wordpress.com/2015/04/cone.jpg 320w"></a></p>
<p>Naturality requires that all triangles (the walls of the pyramid) in this diagram commute. Indeed, take any morphism <code>f</code> in <em>I</em>. The functor D maps it to a morphism <code>D f</code> in <em>C</em>, a morphism that forms the base of some triangle. The constant functor &#x394;<sub>c</sub> maps <code>f</code> to the identity morphism on <code>c</code>. &#x394; squishes the two ends of the morphism into one object, and the naturality square becomes a commuting triangle. The two arms of this triangle are the components of the natural transformation.</p>
<p><a href="https://bartoszmilewski.files.wordpress.com/2015/04/conenaturality.jpg"><img class="alignnone size-medium wp-image-4486" src="https://bartoszmilewski.files.wordpress.com/2015/04/conenaturality.jpg?w=300&amp;h=232%20300w,%20https://bartoszmilewski.files.wordpress.com/2015/04/conenaturality.jpg?w=150&amp;h=116%20150w,%20https://bartoszmilewski.files.wordpress.com/2015/04/conenaturality.jpg%20320w" alt="ConeNaturality" width="300" srcset="https://bartoszmilewski.files.wordpress.com/2015/04/conenaturality.jpg?w=300&amp;h=232 300w, https://bartoszmilewski.files.wordpress.com/2015/04/conenaturality.jpg?w=150&amp;h=116 150w, https://bartoszmilewski.files.wordpress.com/2015/04/conenaturality.jpg 320w"></a></p>
<p>So that&#x2019;s one cone. What we are interested in is the <em>universal cone</em> &#x2014; just like we picked a universal object for our definition of a product.</p>
<p>There are many ways to go about it. For instance, we may define a <em>category of cones</em> based on a given functor D. Objects in that category are cones. Not every object <code>c</code> in <em>C</em>&#xA0;can be an apex of a cone, though, because there may be no natural transformation between &#x394;<sub>c</sub> and D.</p>
<p>To make it a category, we also have to define morphisms between cones. These would be fully determined by morphisms between their apexes. But not just any morphism will do. Remember that, in our construction of the product, we imposed the condition that the morphisms between candidate objects (the apexes) must be common factors for the projections. For instance:</p>
<pre>p&apos; = p . m q&apos; = q . m</pre>
<p><a href="https://bartoszmilewski.files.wordpress.com/2014/12/productranking.jpg"><img class="alignnone wp-image-3772 " src="https://bartoszmilewski.files.wordpress.com/2014/12/productranking.jpg?w=205&amp;h=167%20205w,%20https://bartoszmilewski.files.wordpress.com/2014/12/productranking.jpg?w=410&amp;h=334%20410w,%20https://bartoszmilewski.files.wordpress.com/2014/12/productranking.jpg?w=150&amp;h=122%20150w,%20https://bartoszmilewski.files.wordpress.com/2014/12/productranking.jpg?w=300&amp;h=244%20300w" alt="ProductRanking" width="205" srcset="https://bartoszmilewski.files.wordpress.com/2014/12/productranking.jpg?w=205&amp;h=167 205w, https://bartoszmilewski.files.wordpress.com/2014/12/productranking.jpg?w=410&amp;h=334 410w, https://bartoszmilewski.files.wordpress.com/2014/12/productranking.jpg?w=150&amp;h=122 150w, https://bartoszmilewski.files.wordpress.com/2014/12/productranking.jpg?w=300&amp;h=244 300w"></a></p>
<p>This condition translates, in the general case, to the condition that the triangles whose one side is the factorizing morphism all commute.</p>
<div id="attachment_4487" class="wp-caption alignnone"><a href="https://bartoszmilewski.files.wordpress.com/2015/04/conecommutativity.jpg"><img class="wp-image-4487" src="https://bartoszmilewski.files.wordpress.com/2015/04/conecommutativity.jpg?w=239&amp;h=214%20239w,%20https://bartoszmilewski.files.wordpress.com/2015/04/conecommutativity.jpg?w=150&amp;h=135%20150w,%20https://bartoszmilewski.files.wordpress.com/2015/04/conecommutativity.jpg?w=300&amp;h=269%20300w,%20https://bartoszmilewski.files.wordpress.com/2015/04/conecommutativity.jpg%20320w" alt="Cone Commutativity" width="239" srcset="https://bartoszmilewski.files.wordpress.com/2015/04/conecommutativity.jpg?w=239&amp;h=214 239w, https://bartoszmilewski.files.wordpress.com/2015/04/conecommutativity.jpg?w=150&amp;h=135 150w, https://bartoszmilewski.files.wordpress.com/2015/04/conecommutativity.jpg?w=300&amp;h=269 300w, https://bartoszmilewski.files.wordpress.com/2015/04/conecommutativity.jpg 320w"></a><p class="wp-caption-text">The commuting triangle connecting two cones, with the factorizing morphism <code>h</code>&#xA0; (here, the lower cone is the universal one, with <code>Lim D</code> as its apex).</p></div>
<p>We&#x2019;ll take those factorizing morphisms as the morphisms in our category of cones. It&#x2019;s easy to check that those morphisms indeed compose, and that the identity morphism is a factorizing morphism as well. Cones therefore form a category.</p>
<p>Now we can define the universal cone as the <em>terminal object</em> in the category of cones. The definition of the terminal object states that there is a unique morphism from any other object to that object. In our case it means that there is a unique factorizing morphism from the apex of any other cone to the apex of the universal cone. We call this universal cone the <em>limit</em> of the diagram D, <code>Lim D</code> (in the literature, you&#x2019;ll often see a left arrow pointing towards <em>I</em> under the <code>Lim</code> sign). Often, as a shorthand, we call the apex of this cone the limit (or the limit object).</p>
<p>The intuition is that the limit embodies the properties of the whole diagram in a single object. For instance, the limit of our two-object diagram is the product of two objects. The product (together with the two projections) contains the information about both objects. And being universal means that it has no extraneous junk.</p>
<h2>Limit as a Natural Isomorphism</h2>
<p>There is still something unsatisfying about this definition of a limit. I mean, it&#x2019;s workable, but we still have this commutativity condition for the triangles that are linking any two cones. It would be so much more elegant if we could replace it with some naturality condition. But how?</p>
<p>We are no longer dealing with one cone but with a whole collection (in fact, a category) of cones. If the limit exists (and &#x2014; let&#x2019;s make it clear &#x2014; there&#x2019;s no guarantee of that), one of those cones is the universal cone. For every other cone we have a unique factorizing morphism that maps its apex, let&#x2019;s call it <code>c</code>, to the apex of the universal cone, which we named <code>Lim D</code>. (In fact, I can skip the word &#x201C;other,&#x201D; because the identity morphism maps the universal cone to itself and it trivially factorizes through itself.) Let me repeat the important part: given any cone, there is a unique morphism of a special kind. We have a mapping of cones to special morphisms, and it&#x2019;s a one-to-one mapping.</p>
<p>This special morphism is a member of the hom-set <code>C(c, Lim D)</code>. The other members of this hom-set are less fortunate, in the sense that they don&#x2019;t factorize the mapping of cones. What we want is to be able to pick, for each <code>c</code>, one morphism from the set <code>C(c, Lim D)</code> &#x2014; a morphism that satisfies the particular commutativity condition. Does that sound like defining a natural transformation? It most certainly does!</p>
<p>But what are the functors that are related by this transformation?</p>
<p>One functor is the mapping of <code>c</code> to the set <code>C(c, Lim D)</code>. It&#x2019;s a functor from <em>C</em> to <b>Set</b> &#x2014; it maps objects to sets. In fact it&#x2019;s a contravariant functor. Here&#x2019;s how we define its action on morphisms: Let&#x2019;s take a morphism <code>f</code> from <code>c&apos;</code> to <code>c</code>:</p>
<pre>f :: c&apos; -&gt; c</pre>
<p>Our functor maps <code>c&apos;</code> to the set <code>C(c&apos;, Lim D)</code>. To define the action of this functor on <code>f</code> (in other words, to lift <code>f</code>), we have to define the corresponding mapping between <code>C(c, Lim D)</code> and <code>C(c&apos;, Lim D)</code>. So let&#x2019;s pick one element <code>u</code> of <code>C(c, Lim D)</code> and see if we can map it to some element of <code>C(c&apos;, Lim D)</code>. An element of a hom-set is a morphism, so we have:</p>
<pre>u :: c -&gt; Lim D</pre>
<p>We can precompose <code>u</code> with <code>f</code> to get:</p>
<pre>u . f :: c&apos; -&gt; Lim D</pre>
<p>And that&#x2019;s an element of <code>C(c&apos;, Lim D)</code>&#x2014; so indeed, we have found a mapping of morphisms:</p>
<pre>contramap :: (c&apos; -&gt; c) -&gt; (c -&gt; Lim D) -&gt; (c&apos; -&gt; Lim D) contramap f u = u . f</pre>
<p>Notice the inversion in the order of <code>c</code> and <code>c&apos;</code> characteristic of a <em>contravariant</em> functor.</p>
<p><a href="https://bartoszmilewski.files.wordpress.com/2015/04/homsetmapping.jpg"><img class="alignnone wp-image-4488" src="https://bartoszmilewski.files.wordpress.com/2015/04/homsetmapping.jpg?w=249&amp;h=200%20249w,%20https://bartoszmilewski.files.wordpress.com/2015/04/homsetmapping.jpg?w=150&amp;h=120%20150w,%20https://bartoszmilewski.files.wordpress.com/2015/04/homsetmapping.jpg?w=300&amp;h=241%20300w,%20https://bartoszmilewski.files.wordpress.com/2015/04/homsetmapping.jpg%20320w" alt="HomSetMapping" width="249" srcset="https://bartoszmilewski.files.wordpress.com/2015/04/homsetmapping.jpg?w=249&amp;h=200 249w, https://bartoszmilewski.files.wordpress.com/2015/04/homsetmapping.jpg?w=150&amp;h=120 150w, https://bartoszmilewski.files.wordpress.com/2015/04/homsetmapping.jpg?w=300&amp;h=241 300w, https://bartoszmilewski.files.wordpress.com/2015/04/homsetmapping.jpg 320w"></a></p>
<p>To define a natural transformation, we need another functor that&#x2019;s also a mapping from <em>C</em> to <b>Set</b>. But this time we&#x2019;ll consider a set of cones. Cones are just natural transformations, so we are looking at the set of natural transformations <code>Nat(&#x394;<sub>c</sub>, D)</code>. The mapping from <code>c</code> to this particular set of natural transformations is a (contravariant) functor. How can we show that? Again, let&#x2019;s define its action on a morphism:</p>
<pre>f :: c&apos; -&gt; c</pre>
<p>The lifting of <code>f</code> should be a mapping of natural transformations between two functors that go from <em>I</em> to <em>C</em>:</p>
<pre>Nat(&#x394;<sub>c</sub>, D) -&gt; Nat(&#x394;<sub>c&apos;</sub>, D)</pre>
<p>How do we map natural transformations? Every natural transformation is a selection of morphisms &#x2014; its components &#x2014; one morphism per element of <em>I</em>. A component of some &#x3B1; (a member of <code>Nat(&#x394;<sub>c</sub>, D)</code>) at <code>a</code> (an object in <em>I</em>) is a morphism:</p>
<pre>&#x3B1;<sub>a</sub> :: &#x394;<sub>c</sub>a -&gt; D a</pre>
<p>or, using the definition of the constant functor &#x394;,</p>
<pre>&#x3B1;<sub>a</sub> :: c -&gt; D a</pre>
<p>Given <code>f</code> and &#x3B1;, we have to construct a &#x3B2;, a member of <code>Nat(&#x394;<sub>c&apos;</sub>, D)</code>. Its component at <code>a</code> should be a morphism:</p>
<pre>&#x3B2;<sub>a</sub> :: c&apos; -&gt; D a</pre>
<p>We can easily get the latter from the former by precomposing it with <code>f</code>:</p>
<pre>&#x3B2;<sub>a</sub> = &#x3B1;<sub>a</sub> . f</pre>
<p>It&#x2019;s relatively easy to show that those components indeed add up to a natural transformation.<br>
<a href="https://bartoszmilewski.files.wordpress.com/2015/04/natmapping.jpg"><img class="alignnone size-medium wp-image-4489" src="https://bartoszmilewski.files.wordpress.com/2015/04/natmapping.jpg?w=300&amp;h=194%20300w,%20https://bartoszmilewski.files.wordpress.com/2015/04/natmapping.jpg?w=150&amp;h=97%20150w,%20https://bartoszmilewski.files.wordpress.com/2015/04/natmapping.jpg%20320w" alt="NatMapping" width="300" srcset="https://bartoszmilewski.files.wordpress.com/2015/04/natmapping.jpg?w=300&amp;h=194 300w, https://bartoszmilewski.files.wordpress.com/2015/04/natmapping.jpg?w=150&amp;h=97 150w, https://bartoszmilewski.files.wordpress.com/2015/04/natmapping.jpg 320w"></a></p>
<p>Given our morphism <code>f</code>, we have thus built a mapping between two natural transformations, component-wise. This mapping defines <code>contramap</code> for the functor:</p>
<pre>c -&gt; Nat(&#x394;<sub>c</sub>, D)</pre>
<p>What I have just done is to show you that we have two (contravariant) functors from <em>C</em> to <b>Set</b>. I haven&#x2019;t made any assumptions &#x2014; these functors always exist.</p>
<p>Incidentally, the first of these functors plays an important role in category theory, and we&#x2019;ll see it again when we talk about Yoneda&#x2019;s lemma. There is a name for contravariant functors from any category <em>C</em> to <b>Set</b>: they are called &#x201C;presheaves.&#x201D; This one is called a <em>representable presheaf</em>. The second functor is also a presheaf.</p>
<p>Now that we have two functors, we can talk about natural transformations between them. So without further ado, here&#x2019;s the conclusion: A functor <code>D</code> from <em>I</em> to <em>C</em> has a limit <code>Lim D</code> if and only if there is a natural isomorphism between the two functors I have just defined:</p>
<pre>C(c, Lim D) &#x2243; Nat(&#x394;<sub>c</sub>, D)</pre>
<p>Let me remind you what a natural isomorphism is. It&#x2019;s a natural transformation whose every component is an isomorphism, that is to say an invertible morphism.</p>
<p>I&#x2019;m not going to go through the proof of this statement. The procedure is pretty straightforward if not tedious. When dealing with natural transformations, you usually focus on components, which are morphisms. In this case, since the target of both functors is <b>Set</b>, the components of the natural isomorphism will be functions. These are higher order functions, because they go from the hom-set to the set of natural transformations. Again, you can analyze a function by considering what it does to its argument: here the argument will be a morphism &#x2014; a member of <code>C(c, Lim D)</code> &#x2014; and the result will be a natural transformation &#x2014; a member of <code>Nat(&#x394;<sub>c</sub>, D)</code>, or what we have called a cone. This natural transformation, in turn, has its own components, which are morphisms. So it&#x2019;s morphisms all the way down, and if you can keep track of them, you can prove the statement.</p>
<p>The most important result is that the naturality condition for this isomorphism is exactly the commutativity condition for the mapping of cones.</p>
<p>As a preview of coming attractions, let me mention that the set <code>Nat(&#x394;<sub>c</sub>, D)</code> can be thought of as a hom-set in the functor category; so our natural isomorphism relates two hom-sets, which points at an even more general relationship called an adjunction.</p>
<h2>Examples of Limits</h2>
<p>We&#x2019;ve seen that the categorical product is a limit of a diagram generated by a simple category we called <b>2</b>.</p>
<p>There is an even simpler example of a limit: the terminal object. The first impulse would be to think of a singleton category as leading to a terminal object, but the truth is even starker than that: the terminal object is a limit generated by an empty category. A functor from an empty category selects no object, so a cone shrinks to just the apex. The universal cone is the lone apex that has a unique morphism coming to it from any other apex. You will recognize this as the definition of the terminal object.</p>
<p>The next interesting limit is called the <em>equalizer</em>. It&#x2019;s a limit generated by a two-element category with two parallel morphisms going between them (and, as always, the identity morphisms). This category selects a diagram in <em>C</em> consisting of two objects, <code>a</code> and <code>b</code>, and two morphisms:</p>
<pre>f :: a -&gt; b g :: a -&gt; b</pre>
<p>To build a cone over this diagram, we have to add the apex, <code>c</code> and two projections:</p>
<pre>p :: c -&gt; a q :: c -&gt; b</pre>
<p><a href="https://bartoszmilewski.files.wordpress.com/2015/04/equalizercone.jpg"><img class="alignnone wp-image-4490" src="https://bartoszmilewski.files.wordpress.com/2015/04/equalizercone.jpg?w=218&amp;h=201%20218w,%20https://bartoszmilewski.files.wordpress.com/2015/04/equalizercone.jpg?w=150&amp;h=138%20150w,%20https://bartoszmilewski.files.wordpress.com/2015/04/equalizercone.jpg?w=300&amp;h=277%20300w,%20https://bartoszmilewski.files.wordpress.com/2015/04/equalizercone.jpg%20320w" alt="EqualizerCone" width="218" srcset="https://bartoszmilewski.files.wordpress.com/2015/04/equalizercone.jpg?w=218&amp;h=201 218w, https://bartoszmilewski.files.wordpress.com/2015/04/equalizercone.jpg?w=150&amp;h=138 150w, https://bartoszmilewski.files.wordpress.com/2015/04/equalizercone.jpg?w=300&amp;h=277 300w, https://bartoszmilewski.files.wordpress.com/2015/04/equalizercone.jpg 320w"></a></p>
<p>We have two triangles that must commute:</p>
<pre>q = f . p q = g . p</pre>
<p>This tells us that <code>q</code> is uniquely determined by one of these equations, say, <code>q = f . p</code>, and we can omit it from the picture. So we are left with just one condition:</p>
<pre>f . p = g . p</pre>
<p>The way to think about it is that, if we restrict our attention to <b>Set</b>, the image of the function <code>p</code> selects a subset of <code>a</code>. When restricted to this subset, the functions <code>f</code> and <code>g</code> are equal.</p>
<p>For instance, take <code>a</code> to be the two-dimensional plane parameterized by coordinates <code>x</code> and <code>y</code>. Take <code>b</code> to be the real line, and take:</p>
<pre>f (x, y) = 2 * y + x g (x, y) = y - x</pre>
<p>The equalizer for these two functions is the set of real numbers (the apex, <code>c</code>) and the function:</p>
<pre>p t = (t, (-2) * t)</pre>
<p>Notice that <code>(p t)</code> defines a straight line in the two-dimensional plane. Along this line, the two functions are equal.</p>
<p>Of course, there are other sets <code>c&apos;</code> and functions <code>p&apos;</code> that may lead to the equality:</p>
<pre>f . p&apos; = g . p&apos;</pre>
<p>but they all uniquely factor out through <code>p</code>. For instance, we can take the singleton set <code>()</code> as <code>c&apos;</code> and the function:</p>
<pre>p&apos;() = (0, 0)</pre>
<p>It&#x2019;s a good cone, because <code>f (0, 0) = g (0, 0)</code>. But it&#x2019;s not universal, because of the unique factorization through <code>h</code>:</p>
<pre>p&apos; = p . h</pre>
<p>with</p>
<pre>h () = 0</pre>
<p><a href="https://bartoszmilewski.files.wordpress.com/2015/04/equilizerlimit.jpg"><img class="alignnone wp-image-4491" src="https://bartoszmilewski.files.wordpress.com/2015/04/equilizerlimit.jpg?w=211&amp;h=223%20211w,%20https://bartoszmilewski.files.wordpress.com/2015/04/equilizerlimit.jpg?w=142&amp;h=150%20142w,%20https://bartoszmilewski.files.wordpress.com/2015/04/equilizerlimit.jpg?w=284&amp;h=300%20284w,%20https://bartoszmilewski.files.wordpress.com/2015/04/equilizerlimit.jpg%20303w" alt="EquilizerLimit" width="211" srcset="https://bartoszmilewski.files.wordpress.com/2015/04/equilizerlimit.jpg?w=211&amp;h=223 211w, https://bartoszmilewski.files.wordpress.com/2015/04/equilizerlimit.jpg?w=142&amp;h=150 142w, https://bartoszmilewski.files.wordpress.com/2015/04/equilizerlimit.jpg?w=284&amp;h=300 284w, https://bartoszmilewski.files.wordpress.com/2015/04/equilizerlimit.jpg 303w"></a><br>
An equalizer can thus be used to solve equations of the type <code>f x = g x</code>. But it&#x2019;s much more general, because it&#x2019;s defined in terms of objects and morphisms rather than algebraically.</p>
<p>An even more general idea of solving an equation is embodied in another limit &#x2014; the pullback. Here, we still have two morphisms that we want to equate, but this time their domains are different. We start with a three-object category of the shape: <code>1-&gt;2&lt;-3</code>. The diagram corresponding to this category consists of three objects, <code>a</code>, <code>b</code>, and <code>c</code>, and two morphisms:</p>
<pre>f :: a -&gt; b g :: c -&gt; b</pre>
<p>This diagram is often called a <em>cospan</em>.</p>
<p>A cone built on top of this diagram consists of the apex, <code>d</code>, and three morphisms:</p>
<pre>p :: d -&gt; a q :: d -&gt; c r :: d -&gt; b</pre>
<p><a href="https://bartoszmilewski.files.wordpress.com/2015/04/pullbackcone.jpg"><img class="alignnone wp-image-4492" src="https://bartoszmilewski.files.wordpress.com/2015/04/pullbackcone.jpg?w=238&amp;h=172%20238w,%20https://bartoszmilewski.files.wordpress.com/2015/04/pullbackcone.jpg?w=150&amp;h=108%20150w,%20https://bartoszmilewski.files.wordpress.com/2015/04/pullbackcone.jpg?w=300&amp;h=217%20300w,%20https://bartoszmilewski.files.wordpress.com/2015/04/pullbackcone.jpg%20320w" alt="PullbackCone" width="238" srcset="https://bartoszmilewski.files.wordpress.com/2015/04/pullbackcone.jpg?w=238&amp;h=172 238w, https://bartoszmilewski.files.wordpress.com/2015/04/pullbackcone.jpg?w=150&amp;h=108 150w, https://bartoszmilewski.files.wordpress.com/2015/04/pullbackcone.jpg?w=300&amp;h=217 300w, https://bartoszmilewski.files.wordpress.com/2015/04/pullbackcone.jpg 320w"></a></p>
<p>Commutativity conditions tell us that <code>r</code> is completely determined by the other morphisms, and can be omitted from the picture. So we are only left with the following condition:</p>
<pre>g . q = f . p</pre>
<p>A pullback is a universal cone of this shape.</p>
<p><a href="https://bartoszmilewski.files.wordpress.com/2015/04/pullbacklimit.jpg"><img class="alignnone wp-image-4493" src="https://bartoszmilewski.files.wordpress.com/2015/04/pullbacklimit.jpg?w=204&amp;h=227%20204w,%20https://bartoszmilewski.files.wordpress.com/2015/04/pullbacklimit.jpg?w=135&amp;h=150%20135w,%20https://bartoszmilewski.files.wordpress.com/2015/04/pullbacklimit.jpg%20288w" alt="PullbackLimit" width="204" srcset="https://bartoszmilewski.files.wordpress.com/2015/04/pullbacklimit.jpg?w=204&amp;h=227 204w, https://bartoszmilewski.files.wordpress.com/2015/04/pullbacklimit.jpg?w=135&amp;h=150 135w, https://bartoszmilewski.files.wordpress.com/2015/04/pullbacklimit.jpg 288w"></a></p>
<p>Again, if you narrow your focus down to sets, you can think of the object <code>d</code> as consisting of pairs of elements from <code>a</code> and <code>c</code> for which <code>f</code> acting on the first component is equal to <code>g</code> acting on the second component. If this is still too general, consider the special case in which <code>g</code> is a constant function, say <code>g _ = 1.23</code> (assuming that <code>b</code> is a set of real numbers). Then you are really solving the equation:</p>
<pre>f x = 1.23</pre>
<p>In this case, the choice of <code>c</code> is irrelevant (as long as it&#x2019;s not an empty set), so we can take it to be a singleton set. The set <code>a</code> could, for instance, be the set of three-dimensional vectors, and <code>f</code> the vector length. Then the pullback is the set of pairs <code>(v, ())</code>, where <code>v</code> is a vector of length 1.23 (a solution to the equation <code>sqrt (x<sup>2</sup>+y<sup>2</sup>+z<sup>2</sup>) = 1.23</code>), and <code>()</code> is the dummy element of the singleton set.</p>
<p>But pullbacks have more general applications, also in programming. For instance, consider C++ classes as a category in which morphism are arrows that connect subclasses to superclasses. We&#x2019;ll consider inheritance a transitive property, so if C inherits from B and B inherits from A then we&#x2019;ll say that C inherits from A (after all, you can pass a pointer to C where a pointer to A is expected). Also, we&#x2019;ll assume that C inherits from C, so we have the identity arrow for every class. This way subclassing is aligned with subtyping. C++ also supports multiple inheritance, so you can construct a diamond inheritance diagram with two classes B and C inheriting from A, and a fourth class D multiply inheriting from B and C. Normally, D would get two copies of A, which is rarely desirable; but you can use virtual inheritance to have just one copy of A in D.</p>
<p>What would it mean to have D be a pullback in this diagram? It would mean that any class E that multiply inherits from B and C is also a subclass of D. This is not directly expressible in C++, where subtyping is nominal (the C++ compiler wouldn&#x2019;t infer this kind of class relationship &#x2014; it would require &#x201C;duck typing&#x201D;). But we could go outside of the subtyping relationship and instead ask whether a cast from E to D would be safe or not. This cast would be safe if D were the bare-bone combination of B and C, with no additional data and no overriding of methods. And, of course, there would be no pullback if there is a name conflict between some methods of B and C.</p>
<p><a href="https://bartoszmilewski.files.wordpress.com/2015/04/classes.jpg"><img class="alignnone wp-image-4500" src="https://bartoszmilewski.files.wordpress.com/2015/04/classes.jpg?w=155&amp;h=222%20155w,%20https://bartoszmilewski.files.wordpress.com/2015/04/classes.jpg?w=105&amp;h=150%20105w,%20https://bartoszmilewski.files.wordpress.com/2015/04/classes.jpg%20223w" alt="Classes" width="155" srcset="https://bartoszmilewski.files.wordpress.com/2015/04/classes.jpg?w=155&amp;h=222 155w, https://bartoszmilewski.files.wordpress.com/2015/04/classes.jpg?w=105&amp;h=150 105w, https://bartoszmilewski.files.wordpress.com/2015/04/classes.jpg 223w"></a></p>
<p>There&#x2019;s also a more advanced use of a pullback in type inference. There is often a need to <em>unify</em> types of two expressions. For instance, suppose that the compiler wants to infer the type of a function:</p>
<pre>twice f x = f (f x)</pre>
<p>It will assign preliminary types to all variables and sub-expressions. In particular, it will assign:</p>
<pre>f :: t0 x :: t1 f x :: t2 f (f x) :: t3</pre>
<p>from which it will deduce that:</p>
<pre>twice :: t0 -&gt; t1 -&gt; t3</pre>
<p>It will also come up with a set of constraints resulting from the rules of function application:</p>
<pre>t0 = t1 -&gt; t2 -- because f is applied to x t0 = t2 -&gt; t3 -- because f is applied to (f x)</pre>
<p>These constraints have to be unified by finding a set of types (or type variables) that, when substituted for the unknown types in both expressions, produce the same type. One such substitution is:</p>
<pre>t1 = t2 = t3 = Int twice :: (Int -&gt; Int) -&gt; Int -&gt; Int</pre>
<p>but, obviously, it&#x2019;s not the most general one. The most general substitution is obtained using a pullback. I won&#x2019;t go into the details, because they are beyond the scope of this book, but you can convince yourself that the result should be:</p>
<pre>twice :: (t -&gt; t) -&gt; t -&gt; t</pre>
<p>with <code>t</code> a free type variable.</p>
<h2>Colimits</h2>
<p>Just like all constructions in category theory, limits have their dual image in opposite categories. When you invert the direction of all arrows in a cone, you get a co-cone, and the universal one of those is called a colimit. Notice that the inversion also affects the factorizing morphism, which now flows from the universal co-cone to any other co-cone.</p>
<div id="attachment_4494" class="wp-caption alignnone"><a href="https://bartoszmilewski.files.wordpress.com/2015/04/colimit.jpg"><img class="wp-image-4494 size-thumbnail" src="https://bartoszmilewski.files.wordpress.com/2015/04/colimit.jpg?w=150&amp;h=150%20150w,%20https://bartoszmilewski.files.wordpress.com/2015/04/colimit.jpg?w=298&amp;h=300%20298w" alt="Colimit" srcset="https://bartoszmilewski.files.wordpress.com/2015/04/colimit.jpg?w=150&amp;h=150 150w, https://bartoszmilewski.files.wordpress.com/2015/04/colimit.jpg?w=298&amp;h=300 298w"></a><p class="wp-caption-text">Cocone with a factorizing morphism <code>h</code> connecting two apexes.</p></div>
<p>A typical example of a colimit is a coproduct, which corresponds to the diagram generated by <b>2</b>, the category we&#x2019;ve used in the definition of the product.</p>
<p><a href="https://bartoszmilewski.files.wordpress.com/2014/12/coproductranking.jpg"><img class="alignnone wp-image-3775 size-thumbnail" src="https://bartoszmilewski.files.wordpress.com/2014/12/coproductranking.jpg?w=150&amp;h=125%20150w,%20https://bartoszmilewski.files.wordpress.com/2014/12/coproductranking.jpg?w=300&amp;h=250%20300w" alt="CoproductRanking" width="150" srcset="https://bartoszmilewski.files.wordpress.com/2014/12/coproductranking.jpg?w=150&amp;h=125 150w, https://bartoszmilewski.files.wordpress.com/2014/12/coproductranking.jpg?w=300&amp;h=250 300w"></a></p>
<p>Both the product and the coproduct embody the essence of a pair of objects, each in a different way.</p>
<p>Just like the terminal object was a limit, so the initial object is a colimit corresponding to the diagram based on an empty category.</p>
<p>The dual of the pullback is called the <em>pushout</em>. It&#x2019;s based on a diagram called a span, generated by the category <code>1&lt;-2-&gt;3</code>.</p>
<h2>Continuity</h2>
<p>I said previously that functors come close to the idea of continuous mappings of categories, in the sense that they never break existing connections (morphisms). The actual definition of a <em>continuous functor</em> <code>F</code> from a category <em>C</em> to <em>C&#x2019;</em> includes the requirement that the functor preserve limits. Every diagram <code>D</code> in <em>C</em> can be mapped to a diagram <code>F &#x2218; D</code> in <em>C&#x2019;</em> by simply composing two functors. The continuity condition for <code>F</code> states that, if the diagram <code>D</code> has a limit <code>Lim D</code>, then the diagram <code>F &#x2218; D</code> also has a limit, and it is equal to <code>F (Lim D)</code>.</p>
<p><a href="https://bartoszmilewski.files.wordpress.com/2015/04/continuity.jpg"><img class="alignnone wp-image-4495 size-medium" src="https://bartoszmilewski.files.wordpress.com/2015/04/continuity.jpg?w=300&amp;h=86%20300w,%20https://bartoszmilewski.files.wordpress.com/2015/04/continuity.jpg?w=150&amp;h=43%20150w,%20https://bartoszmilewski.files.wordpress.com/2015/04/continuity.jpg%20320w" alt="Continuity" width="300" srcset="https://bartoszmilewski.files.wordpress.com/2015/04/continuity.jpg?w=300&amp;h=86 300w, https://bartoszmilewski.files.wordpress.com/2015/04/continuity.jpg?w=150&amp;h=43 150w, https://bartoszmilewski.files.wordpress.com/2015/04/continuity.jpg 320w"></a></p>
<p>Notice that, because functors map morphisms to morphisms, and compositions to compositions, an image of a cone is always a cone. A commuting triangle is always mapped to a commuting triangle (functors preserve composition). The same is true for the factorizing morphisms: the image of a factorizing morphism is also a factorizing morphism. So every functor is <em>almost</em> continuous. What may go wrong is the uniqueness condition. The factorizing morphism in <em>C&#x2019;</em> might not be unique. There may also be other &#x201C;better cones&#x201D; in <em>C&#x2019;</em> that were not available in <em>C</em>.</p>
<p>A hom-functor is an example of a continuous functor. Recall that the hom-functor, <code>C(a, b)</code>, is contravariant in the first variable and covariant in the second. In other words, it&#x2019;s a functor:</p>
<pre>C<sup>op</sup> &#xD7; C -&gt; Set</pre>
<p>When its second argument is fixed, the hom-set functor (which becomes the representable presheaf) maps colimits in <em>C</em> to limits in <b>Set</b>; and when its first argument is fixed, it maps limits to limits.</p>
<p>In Haskell, a hom-functor is the mapping of any two types to a function type, so it&#x2019;s just a parameterized function type. When we fix the second parameter, let&#x2019;s say to <code>String</code>, we get the contravariant functor:</p>
<pre>newtype ToString a = ToString (a -&gt; String) instance Contravariant ToString where contramap f (ToString g) = ToString (g . f)</pre>
<p>Continuity means that when <code>ToString</code> is applied to a colimit, for instance a coproduct <code>Either b c</code>, it will produce a limit; in this case a product of two function types:</p>
<pre>ToString (Either b c) ~ (b -&gt; String, c -&gt; String)</pre>
<p>Indeed, any function of <code>Either b c</code> is implemented as a case statement with the two cases being serviced by a pair of functions.</p>
<p>Similarly, when we fix the first argument of the hom-set, we get the familiar reader functor. Its continuity means that, for instance, any function returning a product is equivalent to a product of functions; in particular:</p>
<pre>r -&gt; (a, b) ~ (r -&gt; a, r -&gt; b)</pre>
<p>I know what you&#x2019;re thinking: You don&#x2019;t need category theory to figure these things out. And you&#x2019;re right! Still, I find it amazing that such results can be derived from first principles with no recourse to bits and bytes, processor architectures, compiler technologies, or even lambda calculus.</p>
<p>If you&#x2019;re curious where the names &#x201C;limit&#x201D; and &#x201C;continuity&#x201D; come from, they are a generalization of the corresponding notions from calculus. In calculus limits and continuity are defined in terms of open neighborhoods. Open sets, which define topology, form a category (a poset).</p>
<h2>Challenges</h2>
<ol>
<li>How would you describe a pushout in the category of C++ classes?</li>
<li>Show that the limit of the identity functor <code>Id :: C -&gt; C</code> is the initial object.</li>
<li>Subsets of a given set form a category. A morphism in that category is defined to be an arrow connecting two sets if the first is the subset of the second. What is a pullback of two sets in such a category? What&#x2019;s a pushout? What are the initial and terminal objects?</li>
<li>Can you guess what a coequalizer is?</li>
<li>Show that, in a category with a terminal object, a pullback towards the terminal object is a product.</li>
<li>Similarly, show that a pushout from an initial object (if one exists) is the coproduct.</li>
</ol>
<p>Next: <a href="https://bartoszmilewski.com/2015/07/21/free-monoids/">Free Monoids</a>.</p>
<h2>Acknowledgments</h2>
<p>I&#x2019;d like to thank Gershom Bazerman for checking my math and logic, and Andr&#xE9; van Meulebrouck, who has been volunteering his editing help.<br>
<a href="https://twitter.com/BartoszMilewski" class="twitter-follow-button">Follow @BartoszMilewski</a></p> </div>