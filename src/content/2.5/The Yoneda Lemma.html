<div class="post-content"> <br><blockquote><p>This is part 15 of Categories for Programmers. Previously: <a href="https://bartoszmilewski.com/2015/07/29/representable-functors/">Representable Functors</a>. See the <a href="https://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/">Table of Contents</a>.</p></blockquote>
<p>Most constructions in category theory are generalizations of results from other more specific areas of mathematics. Things like products, coproducts, monoids, exponentials, etc., have been known long before category theory. They might have been known under different names in different branches of mathematics. A cartesian product in set theory, a meet in order theory, a conjunction in logic &#x2014; they are all specific examples of the abstract idea of a categorical product.</p>
<p>The Yoneda lemma stands out in this respect as a sweeping statement about categories in general with little or no precedent in other branches of mathematics. Some say that its closest analog is Cayley&#x2019;s theorem in group theory (every group is isomorphic to a permutation group of some set).</p>
<p>The setting for the Yoneda lemma is an arbitrary category <i>C</i> together with a functor <code>F</code> from <i>C</i> to <b>Set</b>. We&#x2019;ve seen in the previous section that some <b>Set</b>-valued functors are representable, that is isomorphic to a hom-functor. The Yoneda lemma tells us that all <b>Set</b>-valued functors can be obtained from hom-functors through natural transformations, and it explicitly enumerates all such transformations.</p>
<p>When I talked about natural transformations, I mentioned that the naturality condition can be quite restrictive. When you define a component of a natural transformation at one object, naturality may be strong enough to &#x201C;transport&#x201D; this component to another object that is connected to it through a morphism. The more arrows between objects in the source and the target categories there are, the more constraints you have for transporting the components of natural transformations. <b>Set</b> happens to be a very arrow-rich category.</p>
<p>The Yoneda lemma tells us that a natural transformation between a hom-functor and any other functor <code>F</code> is completely determined by specifying the value of its single component at just one point! The rest of the natural transformation just follows from naturality conditions.</p>
<p>So let&#x2019;s review the naturality condition between the two functors involved in the Yoneda lemma. The first functor is the hom-functor. It maps any object <code>x</code> in <i>C</i> to the set of morphisms <code>C(a, x)</code> &#x2014; for <code>a</code> a fixed object in <i>C</i>. We&#x2019;ve also seen that it maps any morphism <code>f</code> from <code>x</code> to <code>y</code> to <code>C(a, f)</code>.</p>
<p>The second functor is an arbitrary <b>Set</b>-valued functor <code>F</code>.</p>
<p>Let&#x2019;s call the natural transformation between these two functors <code>&#x3B1;</code>. Because we are operating in <b>Set</b>, the components of the natural transformation, like <code>&#x3B1;<sub>x</sub></code> or <code>&#x3B1;<sub>y</sub></code>, are just regular functions between sets:</p>
<pre>&#x3B1;<sub>x</sub> :: C(a, x) -&gt; F x &#x3B1;<sub>y</sub> :: C(a, y) -&gt; F y</pre>
<p><a href="https://bartoszmilewski.files.wordpress.com/2015/08/yoneda1.png"><img class="alignnone wp-image-4983 " src="https://bartoszmilewski.files.wordpress.com/2015/08/yoneda1-e1440290035365.png?w=263&amp;h=259%20263w,%20https://bartoszmilewski.files.wordpress.com/2015/08/yoneda1-e1440290035365.png?w=150&amp;h=148%20150w,%20https://bartoszmilewski.files.wordpress.com/2015/08/yoneda1-e1440290035365.png%20295w" alt="Yoneda1" width="263" srcset="https://bartoszmilewski.files.wordpress.com/2015/08/yoneda1-e1440290035365.png?w=263&amp;h=259 263w, https://bartoszmilewski.files.wordpress.com/2015/08/yoneda1-e1440290035365.png?w=150&amp;h=148 150w, https://bartoszmilewski.files.wordpress.com/2015/08/yoneda1-e1440290035365.png 295w"></a></p>
<p>And because these are just functions, we can look at their values at specific points. But what&#x2019;s a point in the set <code>C(a, x)</code>? Here&#x2019;s the key observation: Every point in the set <code>C(a, x)</code> is also a morphism <code>h</code> from <code>a</code> to <code>x</code>.</p>
<p>So the naturality square for <code>&#x3B1;</code>:</p>
<pre>&#x3B1;<sub>y</sub> &#x2218; C(a, f) = F f &#x2218; &#x3B1;<sub>x</sub></pre>
<p>becomes, point-wise, when acting on <code>h</code>:</p>
<pre>&#x3B1;<sub>y</sub> (C(a, f) h) = (F f) (&#x3B1;<sub>x</sub> h)</pre>
<p>You might recall from the previous section that the action of the hom-functor <code>C(a,-)</code> on a morphism <code>f</code> was defined as precomposition:</p>
<pre>C(a, f) h = f &#x2218; h</pre>
<p>which leads to:</p>
<pre>&#x3B1;<sub>y</sub> (f &#x2218; h) = (F f) (&#x3B1;<sub>x</sub> h)</pre>
<p>Just how strong this condition is can be seen by specializing it to the case of <code>x</code> equal to <code>a</code>.</p>
<p><a href="https://bartoszmilewski.files.wordpress.com/2015/08/yoneda2.png"><img class="alignnone size-medium wp-image-4987" src="https://bartoszmilewski.files.wordpress.com/2015/08/yoneda2.png?w=300&amp;h=275%20300w,%20https://bartoszmilewski.files.wordpress.com/2015/08/yoneda2.png?w=150&amp;h=137%20150w,%20https://bartoszmilewski.files.wordpress.com/2015/08/yoneda2.png%20346w" alt="Yoneda2" width="300" srcset="https://bartoszmilewski.files.wordpress.com/2015/08/yoneda2.png?w=300&amp;h=275 300w, https://bartoszmilewski.files.wordpress.com/2015/08/yoneda2.png?w=150&amp;h=137 150w, https://bartoszmilewski.files.wordpress.com/2015/08/yoneda2.png 346w"></a></p>
<p>In that case <code>h</code> becomes a morphism from <code>a</code> to <code>a</code>. We know that there is at least one such morphism, <code>h = id<sub>a</sub></code>. Let&#x2019;s plug it in:</p>
<pre>&#x3B1;<sub>y</sub> f = (F f) (&#x3B1;<sub>a</sub> id<sub>a</sub>)</pre>
<p>Notice what has just happened: The left hand side is the action of <code>&#x3B1;<sub>y</sub></code> on an arbitrary element <code>f</code> of <code>C(a, y)</code>. And it is totally determined by the single value of <code>&#x3B1;<sub>a</sub></code> at <code>id<sub>a</sub></code>. We can pick any such value and it will generate a natural transformation. Since the values of <code>&#x3B1;<sub>a</sub></code> are in the set <code>F a</code>, any point in <code>F a</code> will define some <code>&#x3B1;</code>.</p>
<p>Conversely, given any natural transformation <code>&#x3B1;</code> from <code>C(a, -)</code> to <code>F</code>, you can evaluate it at <code>id<sub>a</sub></code> to get a point in <code>F a</code>.</p>
<p>We have just proven the Yoneda lemma:</p>
<p class="box2">There is a one-to-one correspondence between natural transformations from <code>C(a, -)</code> to <code>F</code> and elements of <code>F a</code>.</p>
<p>in other words,</p>
<pre>Nat(C(a, -), F) &#x2245; F a</pre>
<p>Or, if we use the notation <code>[C, Set]</code> for the functor category between <i>C</i> and <b>Set</b>, the set of natural transformation is just a hom-set in that category, and we can write:</p>
<pre>[C, Set](C(a, -), F) &#x2245; F a</pre>
<p>I&#x2019;ll explain later how this correspondence is in fact a natural isomorphism.</p>
<p>Now let&#x2019;s try to get some intuition about this result. The most amazing thing is that the whole natural transformation crystallizes from just one nucleation site: the value we assign to it at <code>id<sub>a</sub></code>. It spreads from that point following the naturality condition. It floods the image of <i>C</i> in <b>Set</b>. So let&#x2019;s first consider what the image of <i>C</i> is under <code>C(a, -)</code>.</p>
<p>Let&#x2019;s start with the image of <code>a</code> itself. Under the hom-functor <code>C(a, -)</code>, <code>a</code> is mapped to the set <code>C(a, a)</code>. Under the functor <code>F</code>, on the other hand, it is mapped to the set <code>F a</code>. The component of the natural transformation <code>&#x3B1;<sub>a</sub></code> is some function from <code>C(a, a)</code> to <code>F a</code>. Let&#x2019;s focus on just one point in the set <code>C(a, a)</code>, the point corresponding to the morphism <code>id<sub>a</sub></code>. To emphasize the fact that it&#x2019;s just a point in a set, let&#x2019;s call it <code>p</code>. The component <code>&#x3B1;<sub>a</sub></code> should map <code>p</code> to some point <code>q</code> in <code>F a</code>. I&#x2019;ll show you that any choice of <code>q</code> leads to a unique natural transformation.</p>
<p><a href="https://bartoszmilewski.files.wordpress.com/2015/09/yoneda3.png"><img class="alignnone wp-image-5217 size-full" src="https://bartoszmilewski.files.wordpress.com/2015/09/yoneda3.png%20252w,%20https://bartoszmilewski.files.wordpress.com/2015/09/yoneda3.png?w=134%20134w" alt="Yoneda3" srcset="https://bartoszmilewski.files.wordpress.com/2015/09/yoneda3.png 252w, https://bartoszmilewski.files.wordpress.com/2015/09/yoneda3.png?w=134 134w"></a></p>
<p>The first claim is that the choice of one point <code>q</code> uniquely determines the rest of the function <code>&#x3B1;<sub>a</sub></code>. Indeed, let&#x2019;s pick any other point, <code>p&apos;</code> in <code>C(a, a)</code>, corresponding to some morphism <code>g</code> from <code>a</code> to <code>a</code>. And here&#x2019;s where the magic of the Yoneda lemma happens: <code>g</code> can be viewed as a point <code>p&apos;</code> in the set <code>C(a, a)</code>. At the same time, it selects two <em>functions</em> between sets. Indeed, under the hom-functor, the morphism <code>g</code> is mapped to a function <code>C(a, g)</code>; and under <code>F</code> it&#x2019;s mapped to <code>F g</code>.</p>
<p><a href="https://bartoszmilewski.files.wordpress.com/2015/09/yoneda4.png"><img class="alignnone wp-image-5218 size-full" src="https://bartoszmilewski.files.wordpress.com/2015/09/yoneda4.png%20433w,%20https://bartoszmilewski.files.wordpress.com/2015/09/yoneda4.png?w=150%20150w,%20https://bartoszmilewski.files.wordpress.com/2015/09/yoneda4.png?w=300%20300w" alt="Yoneda4" srcset="https://bartoszmilewski.files.wordpress.com/2015/09/yoneda4.png 433w, https://bartoszmilewski.files.wordpress.com/2015/09/yoneda4.png?w=150 150w, https://bartoszmilewski.files.wordpress.com/2015/09/yoneda4.png?w=300 300w"></a></p>
<p>Now let&#x2019;s consider the action of <code>C(a, g)</code> on our original <code>p</code> which, as you remember, corresponds to <code>id<sub>a</sub></code>. It is defined as precomposition, <code>g&#x2218;id<sub>a</sub></code>, which is equal to <code>g</code>, which corresponds to our point <code>p&apos;</code>. So the morphism <code>g</code> is mapped to a function that, when acting on <code>p</code> produces <code>p&apos;</code>, which is <code>g</code>. We have come full circle!</p>
<p>Now consider the action of <code>F g</code> on <code>q</code>. It is some <code>q&apos;</code>, a point in <code>F a</code>. To complete the naturality square, <code>p&apos;</code> must be mapped to <code>q&apos;</code> under <code>&#x3B1;<sub>a</sub></code>. We picked an arbitrary <code>p&apos;</code> (an arbitrary <code>g</code>) and derived its mapping under <code>&#x3B1;<sub>a</sub></code>. The function <code>&#x3B1;<sub>a</sub></code> is thus completely determined.</p>
<p>The second claim is that <code>&#x3B1;<sub>x</sub></code> is uniquely determined for any object <code>x</code> in <i>C</i> that is connected to <code>a</code>. The reasoning is analogous, except that now we have two more sets, <code>C(a, x)</code> and <code>F x</code>, and the morphism <code>g</code> from <code>a</code> to <code>x</code> is mapped, under the hom-functor, to:</p>
<pre>C(a, g) :: C(a, a) -&gt; C(a, x)</pre>
<p>and under <code>F</code> to:</p>
<pre>F g :: F a -&gt; F x</pre>
<p>Again, <code>C(a, g)</code> acting on our <code>p</code> is given by the precomposition: <code>g &#x2218; id<sub>a</sub></code>, which corresponds to a point <code>p&apos;</code> in <code>C(a, x)</code>. Naturality determines the value of <code>&#x3B1;<sub>x</sub></code> acting on <code>p&apos;</code> to be:</p>
<pre>q&apos; = (F g) q</pre>
<p>Since <code>p&apos;</code> was arbitrary, the whole function <code>&#x3B1;<sub>x</sub></code> is thus determined.</p>
<p><a href="https://bartoszmilewski.files.wordpress.com/2015/09/yoneda5.png"><img class="alignnone wp-image-5219 size-full" src="https://bartoszmilewski.files.wordpress.com/2015/09/yoneda5.png%20449w,%20https://bartoszmilewski.files.wordpress.com/2015/09/yoneda5.png?w=150%20150w,%20https://bartoszmilewski.files.wordpress.com/2015/09/yoneda5.png?w=300%20300w" alt="Yoneda5" srcset="https://bartoszmilewski.files.wordpress.com/2015/09/yoneda5.png 449w, https://bartoszmilewski.files.wordpress.com/2015/09/yoneda5.png?w=150 150w, https://bartoszmilewski.files.wordpress.com/2015/09/yoneda5.png?w=300 300w"></a></p>
<p>What if there are objects in <i>C</i> that have no connection to <code>a</code>? They are all mapped under <code>C(a, -)</code> to a single set &#x2014; the empty set. Recall that the empty set is the initial object in the category of sets. It means that there is a unique function from this set to any other set. We called this function <code>absurd</code>. So here, again, we have no choice for the component of the natural transformation: it can only be <code>absurd</code>.</p>
<p>One way of understanding the Yoneda lemma is to realize that natural transformations between <b>Set</b>-valued functors are just families of functions, and functions are in general lossy. A function may collapse information and it may cover only parts of its codomain. The only functions that are not lossy are the ones that are invertible &#x2014; the isomorphisms. It follows then that the best structure-preserving <b>Set</b>-valued functors are the representable ones. They are either the hom-functors or&#xA0;the functors that are naturally isomorphic to hom-functors. Any other functor <code>F</code> is obtained from a hom-functor through a lossy transformation. Such a transformation may not only lose information, but it may also cover only a small part of the image of the functor <code>F</code> in <b>Set</b>.</p>
<h2>Yoneda in Haskell</h2>
<p>We have already encountered the hom-functor in Haskell under the guise of the reader functor:</p>
<pre>type Reader a x = a -&gt; x</pre>
<p>The reader maps morphisms (here, functions) by precomposition:</p>
<pre>instance Functor (Reader a) where fmap f h = f . h</pre>
<p>The Yoneda lemma tells us that the reader functor can be naturally mapped to any other functor.</p>
<p>A natural transformation is a polymorphic function. So given a functor <code>F</code>, we have a mapping to it from the reader functor:</p>
<pre>alpha :: forall x . (a -&gt; x) -&gt; F x</pre>
<p>As usual, <code>forall</code> is optional, but I like to write it explicitly to emphasize parametric polymorphism of natural transformations.</p>
<p>The Yoneda lemma tells us that these natural transformations are in one-to-one correspondence with the elements of <code>F a</code>:</p>
<pre>forall x . (a -&gt; x) -&gt; F x &#x2245; F a</pre>
<p>The right hand side of this identity is what we would normally consider a data structure. Remember the interpretation of functors as generalized containers? <code>F a</code> is a container of <code>a</code>. But the left hand side is a polymorphic function that takes a function as an argument. The Yoneda lemma tells us that the two representations are equivalent &#x2014; they contain the same information.</p>
<p>Another way of saying this is: Give me a polymorphic function of the type:</p>
<pre>alpha :: forall x . (a -&gt; x) -&gt; F x</pre>
<p>and I&#x2019;ll produce a container of <code>a</code>. The trick is the one we used in the proof of the Yoneda lemma: we call this function with <code>id</code> to get an element of <code>F a</code>:</p>
<pre>alpha id :: F a</pre>
<p>The converse is also true: Given a value of the type <code>F a</code>:</p>
<pre>fa :: F a</pre>
<p>one can define a polymorphic function:</p>
<pre>alpha h = fmap h fa</pre>
<p>of the correct type. You can easily go back and forth between the two representations.</p>
<p>The advantage of having multiple representations is that one might be easier to compose than the other, or that one might be more efficient in some applications than the other.</p>
<p>The simplest illustration of this principle is the code transformation that is often used in compiler construction: the continuation passing style or CPS. It&#x2019;s the simplest application of the Yoneda lemma to the identity functor. Replacing <code>F</code> with identity produces:</p>
<pre>forall r . (a -&gt; r) -&gt; r &#x2245; a</pre>
<p>The interpretation of this formula is that any type <code>a</code> can be replaced by a function that takes a &#x201C;handler&#x201D; for <code>a</code>. A handler is a function accepting <code>a</code> and performing the rest of the computation &#x2014; the continuation. (The type <code>r</code> usually encapsulates some kind of status code.)</p>
<p>This style of programming is very common in UIs, in asynchronous systems, and in concurrent programming. The drawback of CPS is that it involves inversion of control. The code is split between producers and consumers (handlers), and is not easily composable. Anybody who&#x2019;s done any amount of nontrivial web programming is familiar with the nightmare of spaghetti code from interacting stateful handlers. As we&#x2019;ll see later, judicious use of functors and monads can restore some compositional properties of CPS.</p>
<h2>Co-Yoneda</h2>
<p>As usual, we get a bonus construction by inverting the direction of arrows. The Yoneda lemma can be applied to the opposite category <i>C</i><sup>op</sup> to give us a mapping between contravariant functors.</p>
<p>Equivalently, we can derive the co-Yoneda lemma by fixing the target object of our hom-functors instead of the source. We get the contravariant hom-functor from <i>C</i> to <b>Set</b>: <code>C(-, a)</code>. The contravariant version of the Yoneda lemma establishes one-to-one correspondence between natural transformations from this functor to any other contravariant functor <code>F</code> and the elements of the set <code>F a</code>:</p>
<pre>Nat(C(-, a), F) &#x2245; F a</pre>
<p>Here&#x2019;s the Haskell version of the co-Yoneda lemma:</p>
<pre>forall x . (x -&gt; a) -&gt; F x &#x2245; F a</pre>
<p>Notice that in some literature it&#x2019;s the contravariant version that&#x2019;s called the Yoneda lemma.</p>
<h2>Challenges</h2>
<ol>
<li>Show that the two functions <code>phi</code> and <code>psi</code> that form the Yoneda isomorphism in Haskell are inverses of each other.
<pre>phi :: (forall x . (a -&gt; x) -&gt; F x) -&gt; F a phi alpha = alpha id</pre>
<pre>psi :: F a -&gt; (forall x . (a -&gt; x) -&gt; F x) psi fa h = fmap h fa</pre>
</li>
<li>A discrete category is one that has objects but no morphisms other than identity morphisms. How does the Yoneda lemma work for functors from such a category?</li>
<li>A list of units <code>[()]</code> contains no other information but its length. So, as a data type, it can be considered an encoding of integers. An empty list encodes zero, a singleton <code>[()]</code> (a value, not a type) encodes one, and so on. Construct another representation of this data type using the Yoneda lemma for the list functor.</li>
</ol>
<h2>Bibliography</h2> <p>Next: <a href="https://bartoszmilewski.com/2015/10/28/yoneda-embedding/">Yoneda Embedding</a>.</p>
<h2>Acknowledgments</h2>
<p>I&#x2019;d like to thank Gershom Bazerman for checking my math and logic, and Andr&#xE9; van Meulebrouck, who has been volunteering his editing help throughout this series of posts.<br>
<a href="https://twitter.com/BartoszMilewski" class="twitter-follow-button">Follow @BartoszMilewski</a></p> </div>