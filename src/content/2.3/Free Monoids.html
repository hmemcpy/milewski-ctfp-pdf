<div class="post-content"> <br><blockquote><p>This is part 13 of Categories for Programmers. Previously: <a href="https://bartoszmilewski.com/2015/04/15/limits-and-colimits/">Limits and Colimits</a>. See the <a href="https://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/">Table of Contents</a>.</p></blockquote>
<p>Monoids are an important concept in both category theory and in programming. Categories correspond to strongly typed languages, monoids to untyped languages. That&#x2019;s because in a monoid you can compose any two arrows, just as in an untyped language you can compose any two functions (of course, you may end up with a runtime error when you execute your program).</p>
<p>We&#x2019;ve seen that a monoid may be described as a category with a single object, where all logic is encoded in the rules of morphism composition. This categorical model is fully equivalent to the more traditional set-theoretical definition of a monoid, where we &#x201C;multiply&#x201D; two elements of a set to get a third element. This process of &#x201C;multiplication&#x201D; can be further dissected into first forming a pair of elements and then identifying this pair with an existing element &#x2014; their &#x201C;product.&#x201D;</p>
<p>What happens when we forgo the second part of multiplication &#x2014; the identification of pairs with existing elements? We can, for instance, start with an arbitrary set, form all possible pairs of elements, and call them new elements. Then we&#x2019;ll pair these new elements with all possible elements, and so on. This is a chain reaction &#x2014; we&#x2019;ll keep adding new elements forever. The result, an infinite set, will be <em>almost</em> a monoid. But a monoid also needs a unit element and the law of associativity. No problem, we can add a special unit element and identify some of the pairs &#x2014; just enough to support the unit and associativity laws.</p>
<p>Let&#x2019;s see how this works in a simple example. Let&#x2019;s start with a set of two elements, <code>{a, b}</code>. We&#x2019;ll call them the generators of the free monoid. First, we&#x2019;ll add a special element <code>e</code> to serve as the unit. Next we&#x2019;ll add all the pairs of elements and call them &#x201C;products&#x201D;. The product of <code>a</code> and <code>b</code> will be the pair <code>(a, b)</code>. The product of <code>b</code> and <code>a</code> will be the pair <code>(b, a)</code>, the product of <code>a</code> with <code>a</code> will be <code>(a, a)</code>, the product of <code>b</code> with <code>b</code> will be <code>(b, b)</code>. We can also form pairs with <code>e</code>, like <code>(a, e)</code>, <code>(e, b)</code>, etc., but we&#x2019;ll identify them with <code>a</code>, <code>b</code>, etc. So in this round we&#x2019;ll only add <code>(a, a)</code>, <code>(a, b)</code> and <code>(b, a)</code> and <code>(b, b)</code>, and end up with the set <code>{e, a, b, (a, a), (a, b), (b, a), (b, b)}</code>.</p>
<p><a href="https://bartoszmilewski.files.wordpress.com/2015/07/bunnies.jpg"><img class="alignnone wp-image-4840 " src="https://bartoszmilewski.files.wordpress.com/2015/07/bunnies.jpg?w=436&amp;h=201%20436w,%20https://bartoszmilewski.files.wordpress.com/2015/07/bunnies.jpg?w=150&amp;h=69%20150w,%20https://bartoszmilewski.files.wordpress.com/2015/07/bunnies.jpg?w=300&amp;h=138%20300w,%20https://bartoszmilewski.files.wordpress.com/2015/07/bunnies.jpg%20636w" alt="Bunnies" width="436" srcset="https://bartoszmilewski.files.wordpress.com/2015/07/bunnies.jpg?w=436&amp;h=201 436w, https://bartoszmilewski.files.wordpress.com/2015/07/bunnies.jpg?w=150&amp;h=69 150w, https://bartoszmilewski.files.wordpress.com/2015/07/bunnies.jpg?w=300&amp;h=138 300w, https://bartoszmilewski.files.wordpress.com/2015/07/bunnies.jpg 636w"></a></p>
<p>In the next round we&#x2019;ll keep adding elements like: <code>(a, (a, b))</code>, <code>((a, b), a)</code>, etc. At this point we&#x2019;ll have to make sure that associativity holds, so we&#x2019;ll identify <code>(a, (b, a))</code> with <code>((a, b), a)</code>, etc. In other words, we won&#x2019;t be needing internal parentheses.</p>
<p>You can guess what the final result of this process will be: we&#x2019;ll create all possible lists of <code>a</code>s and <code>b</code>s. In fact, if we represent <code>e</code> as an empty list, we can see that our &#x201C;multiplication&#x201D; is nothing but list concatenation.</p>
<p>This kind of construction, in which you keep generating all possible combinations of elements, and perform the minimum number of identifications &#x2014; just enough to uphold the laws &#x2014; is called a free construction. What we have just done is to construct a <em>free monoid</em> from the set of generators <code>{a, b}</code>.</p>
<h2>Free Monoid in Haskell</h2>
<p>A two-element set in Haskell is equivalent to the type <code>Bool</code>, and the free monoid generated by this set is equivalent to the type <code>[Bool]</code> (list of <code>Bool</code>). (I am deliberately ignoring problems with infinite lists.)</p>
<p>A monoid in Haskell is defined by the type class:</p>
<pre>class Monoid m where mempty :: m mappend :: m -&gt; m -&gt; m</pre>
<p>This just says that every <code>Monoid</code> must have a neutral element, which is called <code>mempty</code>, and a binary function (multiplication) called <code>mappend</code>. The unit and associativity laws cannot be expressed in Haskell and must be verified by the programmer every time a monoid is instantiated.</p>
<p>The fact that a list of any type forms a monoid is described by this instance definition:</p>
<pre>instance Monoid [a] where mempty = [] mappend = (++)</pre>
<p>It states that an empty list <code>[]</code> is the unit element, and list concatenation <code>(++)</code> is the binary operation.</p>
<p>As we have seen, a list of type <code>a</code> corresponds to a free monoid with the set <code>a</code> serving as generators. The set of natural numbers with multiplication is not a free monoid, because we identify lots of products. Compare for instance:</p>
<pre>2 * 3 = 6 [2] ++ [3] = [2, 3] // not the same as [6]</pre>
<p>That was easy, but the question is, can we perform this free construction in category theory, where we are not allowed to look inside objects? We&#x2019;ll use our workhorse: the universal construction.</p>
<p>The second interesting question is, can any monoid be obtained from some free monoid by identifying more than the minimum number of elements required by the laws? I&#x2019;ll show you that this follows directly from the universal construction.</p>
<h2>Free Monoid Universal Construction</h2>
<p>If you recall our previous experiences with universal constructions, you might notice that it&#x2019;s not so much about constructing something as about selecting an object that best fits a given pattern. So if we want to use the universal construction to &#x201C;construct&#x201D; a free monoid, we have to consider a whole bunch of monoids from which to pick one. We need a whole category of monoids to chose from. But do monoids form a category?</p>
<p>Let&#x2019;s first look at monoids as sets equipped with additional structure defined by unit and multiplication. We&#x2019;ll pick as morphisms those functions that preserve the monoidal structure. Such structure-preserving functions are called <em>homomorphisms</em>. A monoid homomorphism must map the product of two elements to the product of the mapping of the two elements:</p>
<pre>h (a * b) = h a * h b</pre>
<p>and it must map unit to unit.<br>
For instance, consider a homomorphism from lists of integers to integers. If we map <code>[2]</code> to 2 and <code>[3]</code> to 3, we have to map <code>[2, 3]</code> to 6, because concatenation</p>
<pre>[2] ++ [3] = [2, 3]</pre>
<p>becomes multiplication</p>
<pre>2 * 3 = 6</pre>
<p>Now let&#x2019;s forget about the internal structure of individual monoids, and only look at them as objects with corresponding morphisms. You get a category <b>Mon</b> of monoids.</p>
<p>Okay, maybe before we forget about internal structure, let us notice an important property. Every object of <b>Mon</b> can be trivially mapped to a set. It&#x2019;s just the set of its elements. This set is called the <i>underlying</i> set. In fact, not only can we map objects of <b>Mon</b> to sets, but we can also map morphisms of <b>Mon</b> (homomorphisms) to functions. Again, this seems sort of trivial, but it will become useful soon. This mapping of objects and morphisms from <b>Mon</b> to <b>Set</b> is in fact a functor. Since this functor &#x201C;forgets&#x201D; the monoidal structure &#x2014; once we are inside a plain set, we no longer distinguish the unit element or care about multiplication &#x2014; it&#x2019;s called a <i>forgetful functor</i>. Forgetful functors come up regularly in category theory.</p>
<p>We now have two different views of <b>Mon</b>. We can treat it just like any other category with objects and morphisms. In that view, we don&#x2019;t see the internal structure of monoids. All we can say about a particular object in <b>Mon</b> is that it connects to itself and to other objects through morphisms. The &#x201C;multiplication&#x201D; table of morphisms &#x2014; the composition rules &#x2014; are derived from the other view: monoids-as-sets. By going to category theory we haven&#x2019;t lost this view completely &#x2014; we can still access it through our forgetful functor.</p>
<p>To apply the universal construction, we need to define a special property that would let us search through the category of monoids and pick the best candidate for a free monoid. But a free monoid is defined by its generators. Different choices of generators produce different free monoids (a list of <code>Bool</code> is not the same as a list of <code>Int</code>). Our construction must start with a set of generators. So we&#x2019;re back to sets!</p>
<p>That&#x2019;s where the forgetful functor comes into play. We can use it to X-ray our monoids. We can identify the generators in the X-ray images of those blobs. Here&#x2019;s how it works:</p>
<p>We start with a set of generators, <code>x</code>. That&#x2019;s a set in <b>Set</b>.</p>
<p>The pattern we are going to match consists of a monoid <code>m</code> &#x2014; an object of <b>Mon</b> &#x2014; and a function <code>p</code> in <b>Set</b>:</p>
<pre>p :: x -&gt; U m</pre>
<p>where <code>U</code> is our forgetful functor from <b>Mon</b> to <b>Set</b>. This is a weird heterogeneous pattern &#x2014; half in <b>Mon</b> and half in <b>Set</b>.</p>
<p>The idea is that the function <code>p</code> will identify the set of generators inside the X-ray image of <code>m</code>. It doesn&#x2019;t matter that functions may be lousy at identifying points inside sets (they may collapse them). It will all be sorted out by the universal construction, which will pick the best representative of this pattern.</p>
<p><a href="https://bartoszmilewski.files.wordpress.com/2015/07/monoid-pattern.jpg"><img class="alignnone size-medium wp-image-4841" src="https://bartoszmilewski.files.wordpress.com/2015/07/monoid-pattern.jpg?w=300&amp;h=185%20300w,%20https://bartoszmilewski.files.wordpress.com/2015/07/monoid-pattern.jpg?w=150&amp;h=93%20150w,%20https://bartoszmilewski.files.wordpress.com/2015/07/monoid-pattern.jpg%20595w" alt="Monoid Pattern" width="300" srcset="https://bartoszmilewski.files.wordpress.com/2015/07/monoid-pattern.jpg?w=300&amp;h=185 300w, https://bartoszmilewski.files.wordpress.com/2015/07/monoid-pattern.jpg?w=150&amp;h=93 150w, https://bartoszmilewski.files.wordpress.com/2015/07/monoid-pattern.jpg 595w"></a></p>
<p>We also have to define the ranking among candidates. Suppose we have another candidate: a monoid <code>n</code> and a function that identifies the generators in its X-ray image:</p>
<pre>q :: x -&gt; U n</pre>
<p>We&#x2019;ll say that <code>m</code> is better than <code>n</code> if there is a morphism of monoids (that&#x2019;s a structure-preserving homomorphism):</p>
<pre>h :: m -&gt; n</pre>
<p>whose image under <code>U</code> (remember, <code>U</code> is a functor, so it maps morphisms to functions) factorizes through <code>p</code>:</p>
<pre>q = U h . p</pre>
<p>If you think of <code>p</code> as selecting the generators in <code>m</code>; and <code>q</code> as selecting &#x201C;the same&#x201D; generators in <code>n</code>; then you can think of <code>h</code> as mapping these generators between the two monoids. Remember that <code>h</code>, by definition, preserves the monoidal structure. It means that a product of two generators in one monoid will be mapped to a product of the corresponding two generators in the second monoid, and so on.</p>
<p><a href="https://bartoszmilewski.files.wordpress.com/2015/07/monoid-ranking.jpg"><img class="alignnone size-medium wp-image-4842" src="https://bartoszmilewski.files.wordpress.com/2015/07/monoid-ranking.jpg?w=300&amp;h=221%20300w,%20https://bartoszmilewski.files.wordpress.com/2015/07/monoid-ranking.jpg?w=600&amp;h=442%20600w,%20https://bartoszmilewski.files.wordpress.com/2015/07/monoid-ranking.jpg?w=150&amp;h=111%20150w" alt="Monoid Ranking" width="300" srcset="https://bartoszmilewski.files.wordpress.com/2015/07/monoid-ranking.jpg?w=300&amp;h=221 300w, https://bartoszmilewski.files.wordpress.com/2015/07/monoid-ranking.jpg?w=600&amp;h=442 600w, https://bartoszmilewski.files.wordpress.com/2015/07/monoid-ranking.jpg?w=150&amp;h=111 150w"></a></p>
<p>This ranking may be used to find the best candidate &#x2014; the free monoid. Here&#x2019;s the definition:</p>
<p class="box2">We&#x2019;ll say that <code>m</code> (together with the function <code>p</code>) is the <strong>free monoid</strong> with the generators <code>x</code> if and only if there is a <em>unique</em> morphism <code>h</code> from <code>m</code> to any other monoid <code>n</code> (together with the function <code>q</code>) that satisfies the above factorization property.</p>
<p>Incidentally, this answers our second question. The function <code>U h</code> is the one that has the power to collapse multiple elements of <code>U m</code> to a single element of <code>U n</code>. This collapse corresponds to identifying some elements of the free monoid. Therefore any monoid with generators <code>x</code> can be obtained from the free monoid based on <code>x</code> by identifying some of the elements. The free monoid is the one where only the bare minimum of identifications have been made.</p>
<p>We&#x2019;ll come back to free monoids when we talk about adjunctions.</p>
<h2>Challenges</h2>
<ol>
<li>You might think (as I did, originally) that the requirement that a homomorphism of monoids preserve the unit is redundant. After all, we know that for all <code>a</code>
<pre>h a * h e = h (a * e) = h a</pre>
<p>So <code>h e</code> acts like a right unit (and, by analogy, as a left unit). The problem is that <code>h a</code>, for all <code>a</code> might only cover a sub-monoid of the target monoid. There may be a &#x201C;true&#x201D; unit outside of the image of <code>h</code>. Show that an isomorphism between monoids that preserves multiplication must automatically preserve unit.</p></li>
<li>Consider a monoid homomorphism from lists of integers with concatenation to integers with multiplication. What is the image of the empty list <code>[]</code>? Assume that all singleton lists are mapped to the integers they contain, that is <code>[3]</code> is mapped to 3, etc. What&#x2019;s the image of <code>[1, 2, 3, 4]</code>? How many different lists map to the integer 12? Is there any other homomorphism between the two monoids?</li>
<li>What is the free monoid generated by a one-element set? Can you see what it&#x2019;s isomorphic to?</li>
</ol>
<p>Next: <a href="https://bartoszmilewski.com/2015/07/29/representable-functors/">Representable Functors</a>.</p>
<h2>Acknowledgments</h2>
<p>I&#x2019;d like to thank Gershom Bazerman for checking my math and logic, and Andr&#xE9; van Meulebrouck, who has been volunteering his editing help throughout this series of posts.<br>
<a href="https://twitter.com/BartoszMilewski" class="twitter-follow-button">Follow @BartoszMilewski</a></p> <p id="geo-post-4377" class="geo"> <span class="latitude">43.193044</span> <span class="longitude">11.286147</span> </p> </div>