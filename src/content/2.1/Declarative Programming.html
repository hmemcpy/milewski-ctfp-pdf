<div class="post-content"> <br><blockquote><p>This is part 11 of Categories for Programmers. Previously: <a href="https://bartoszmilewski.com/2015/04/07/natural-transformations/">Natural Transformations</a>. See the <a href="https://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/">Table of Contents</a>.</p></blockquote> <p>In the first part of the book I argued that both category theory and programming are about composability. In programming, you keep decomposing a problem until you reach the level of detail that you can deal with, solve each subproblem in turn, and re-compose the solutions bottom-up. There are, roughly speaking, two ways of doing it: by telling the computer what to do, or by telling it how to do it. One is called declarative and the other imperative.</p>
<p>You can see this even at the most basic level. Composition itself may be defined declaratively; as in, <code>h</code> is a composite of <code>g</code> after <code>f</code>:</p>
<pre>h = g . f</pre>
<p>or imperatively; as in, call <code>f</code> first, remember the result of that call, then call <code>g</code> with the result:</p>
<pre>h x = let y = f x in g y</pre>
<p>The imperative version of a program is usually described as a sequence of actions ordered in time. In particular, the call to <code>g</code> cannot happen before the execution of <code>f</code> completes. At least, that&#x2019;s the conceptual picture &#x2014; in a lazy language, with <em>call-by-need</em> argument passing, the actual execution may proceed differently.</p>
<p>In fact, depending on the cleverness of the compiler, there may be little or no difference between how declarative and imperative code is executed. But the two methodologies differ, sometimes drastically, in the way we approach problem solving and in the maintainability and testability of the resulting code.</p>
<p>The main question is: when faced with a problem, do we always have the choice between a declarative and imperative approaches to solving it? And, if there is a declarative solution, can it always be translated into computer code? The answer to this question is far from obvious and, if we could find it, we would probably revolutionize our understanding of the universe.</p>
<p>Let me elaborate. There is a similar duality in physics, which either points at some deep underlying principle, or tells us something about how our minds work. Richard Feynman mentions this duality as an inspiration in his own work on quantum electrodynamics.</p>
<p>There are two forms of expressing most laws of physics. One uses local, or infinitesimal, considerations. We look at the state of a system around a small neighborhood, and predict how it will evolve within the next instant of time. This is usually expressed using differential equations that have to be integrated, or summed up, over a period of time.</p>
<p>Notice how this approach resembles imperative thinking: we reach the final solution by following a sequence of small steps, each depending on the result of the previous one. In fact, computer simulations of physical systems are routinely implemented by turning differential equations into difference equations and iterating them. This is how spaceships are animated in the asteroids game. At each time step, the position of a spaceship is changed by adding a small increment, which is calculated by multiplying its velocity by the time delta. The velocity, in turn, is changed by a small increment proportional to acceleration, which is given by force divided by mass.</p>
<p><a href="https://bartoszmilewski.files.wordpress.com/2015/04/asteroids.png"><img class="alignnone size-medium wp-image-4432" src="https://bartoszmilewski.files.wordpress.com/2015/04/asteroids.png?w=300&amp;h=225%20300w,%20https://bartoszmilewski.files.wordpress.com/2015/04/asteroids.png?w=150&amp;h=113%20150w,%20https://bartoszmilewski.files.wordpress.com/2015/04/asteroids.png%20320w" alt="Asteroids" width="300" srcset="https://bartoszmilewski.files.wordpress.com/2015/04/asteroids.png?w=300&amp;h=225 300w, https://bartoszmilewski.files.wordpress.com/2015/04/asteroids.png?w=150&amp;h=113 150w, https://bartoszmilewski.files.wordpress.com/2015/04/asteroids.png 320w"></a></p>
<p>These are the direct encodings of the differential equations corresponding to Newton&#x2019;s laws of motion:</p>
<pre>F = m dv/dt v = dx/dt</pre>
<p>Similar methods may be applied to more complex problems, like the propagation of electromagnetic fields using Maxwell&#x2019;s equations, or even the behavior of quarks and gluons inside a proton using lattice QCD (quantum chromodynamics).</p>
<p>This local thinking combined with discretization of space and time that is encouraged by the use of digital computers found its extreme expression in the heroic attempt by Stephen Wolfram to reduce the complexity of the whole universe to a system of cellular automata.</p>
<p>The other approach is global. We look at the initial and the final state of the system, and calculate a trajectory that connects them by minimizing a certain functional. The simplest example is the Fermat&#x2019;s principle of least time. It states that light rays propagate along paths that minimize their flight time. In particular, in the absence of reflecting or refracting objects, a light ray from point A to point B will take the shortest path, which is a straight line. But light propagates slower in dense (transparent) materials, like water or glass. So if you pick the starting point in the air, and the ending point under water, it&#x2019;s more advantageous for light to travel longer in the air and then take a shortcut through water. The path of minimum time makes the ray refract at the boundary of air and water, resulting in Snell&#x2019;s law of refraction:</p>
<pre>sin &#x3B8;<sub>1</sub> / sin &#x3B8;<sub>2</sub> = v<sub>1</sub> / v<sub>2</sub></pre>
<p>where <code>v<sub>1</sub></code> is the speed of light in the air and <code>v<sub>2</sub></code> is the speed of light in the water.</p>
<p><a href="https://bartoszmilewski.files.wordpress.com/2015/04/snell.jpg"><img class="alignnone size-medium wp-image-4437" src="https://bartoszmilewski.files.wordpress.com/2015/04/snell.jpg?w=224&amp;h=300%20224w,%20https://bartoszmilewski.files.wordpress.com/2015/04/snell.jpg?w=448&amp;h=600%20448w,%20https://bartoszmilewski.files.wordpress.com/2015/04/snell.jpg?w=112&amp;h=150%20112w" alt="Snell" width="224" srcset="https://bartoszmilewski.files.wordpress.com/2015/04/snell.jpg?w=224&amp;h=300 224w, https://bartoszmilewski.files.wordpress.com/2015/04/snell.jpg?w=448&amp;h=600 448w, https://bartoszmilewski.files.wordpress.com/2015/04/snell.jpg?w=112&amp;h=150 112w"></a></p>
<p>All of classical mechanics can be derived from the principle of least action. The action can be calculated for any trajectory by integrating the Lagrangian, which is the difference between kinetic and potential energy (notice: it&#x2019;s the difference, not the sum &#x2014; the sum would be the total energy). When you fire a mortar to hit a given target, the projectile will first go up, where the potential energy due to gravity is higher, and spend some time there racking up negative contribution to the action. It will also slow down at the top of the parabola, to minimize kinetic energy. Then it will speed up to go quickly through the area of low potential energy.</p>
<p><a href="https://bartoszmilewski.files.wordpress.com/2015/04/mortar.jpg"><img src="https://bartoszmilewski.files.wordpress.com/2015/04/mortar.jpg?w=300&amp;h=158%20300w,%20https://bartoszmilewski.files.wordpress.com/2015/04/mortar.jpg?w=598&amp;h=316%20598w,%20https://bartoszmilewski.files.wordpress.com/2015/04/mortar.jpg?w=150&amp;h=79%20150w" alt="Mortar" width="300" class="alignnone size-medium wp-image-4438" srcset="https://bartoszmilewski.files.wordpress.com/2015/04/mortar.jpg?w=300&amp;h=158 300w, https://bartoszmilewski.files.wordpress.com/2015/04/mortar.jpg?w=598&amp;h=316 598w, https://bartoszmilewski.files.wordpress.com/2015/04/mortar.jpg?w=150&amp;h=79 150w"></a></p>
<p>Feynman&#x2019;s greatest contribution was to realize that the principle of least action can be generalized to quantum mechanics. There, again, the problem is formulated in terms of initial state and final state. The Feynman path integral between those states is used to calculate the probability of transition.</p>
<p><a href="https://bartoszmilewski.files.wordpress.com/2015/04/feynman.jpg"><img src="https://bartoszmilewski.files.wordpress.com/2015/04/feynman.jpg?w=300&amp;h=225%20300w,%20https://bartoszmilewski.files.wordpress.com/2015/04/feynman.jpg?w=600&amp;h=450%20600w,%20https://bartoszmilewski.files.wordpress.com/2015/04/feynman.jpg?w=150&amp;h=113%20150w" alt="Feynman" width="300" class="alignnone size-medium wp-image-4439" srcset="https://bartoszmilewski.files.wordpress.com/2015/04/feynman.jpg?w=300&amp;h=225 300w, https://bartoszmilewski.files.wordpress.com/2015/04/feynman.jpg?w=600&amp;h=450 600w, https://bartoszmilewski.files.wordpress.com/2015/04/feynman.jpg?w=150&amp;h=113 150w"></a></p>
<p>The point is that there is a curious unexplained duality in the way we can describe the laws of physics. We can use the local picture, in which things happen sequentially and in small increments. Or we can use the global picture, where we declare the initial and final conditions, and everything in between just follows.</p>
<p>The global approach can be also used in programming, for instance when implementing ray tracing. We declare the position of the eye and the positions of light sources, and figure out the paths that the light rays may take to connect them. We don&#x2019;t explicitly minimize the time of flight for each ray, but we do use Snell&#x2019;s law and the geometry of reflection to the same effect.</p>
<p>The biggest difference between the local and the global approach is in their treatment of space and, more importantly, time. The local approach embraces the immediate gratification of here and now, whereas the global approach takes a long-term static view, as if the future had been preordained, and we were only analyzing the properties of some eternal universe.</p>
<p>Nowhere is it better illustrated than in the Functional Reactive Programming approach to user interaction. Instead of writing separate handlers for every possible user action, all having access to some shared mutable state, FRP treats external events as an infinite list, and applies a series of transformations to it. Conceptually, the list of all our future actions is there, available as the input data to our program. From a program&#x2019;s perspective there&#x2019;s no difference between the list of digits of &#x3C0;, a list of pseudo-random numbers, or a list of mouse positions coming through computer hardware. In each case, if you want to get the nth item, you have to first go through the first n-1 items. When applied to temporal events, we call this property <em>causality</em>.</p>
<p>So what does it have to do with category theory? I will argue that category theory encourages a global approach and therefore supports declarative programming. First of all, unlike calculus, it has no built-in notion of distance, or neighborhood, or time. All we have is abstract objects and abstract connections between them. If you can get from A to B through a series of steps, you can also get there in one leap. Moreover, the major tool of category theory is the universal construction, which is the epitome of a global approach. We&#x2019;ve seen it in action, for instance, in the definition of the categorical product. It was done by specifying its properties &#x2014; a very declarative approach. It&#x2019;s an object equipped with two projections, and it&#x2019;s the best such object &#x2014; it optimizes a certain property: the property of factorizing the projections of other such objects. </p>
<p><a href="https://bartoszmilewski.files.wordpress.com/2014/12/productranking.jpg"><img src="https://bartoszmilewski.files.wordpress.com/2014/12/productranking.jpg?w=300&amp;h=244%20300w,%20https://bartoszmilewski.files.wordpress.com/2014/12/productranking.jpg?w=150&amp;h=122%20150w,%20https://bartoszmilewski.files.wordpress.com/2014/12/productranking.jpg%20541w" alt="ProductRanking" width="300" class="alignnone size-medium wp-image-3772" srcset="https://bartoszmilewski.files.wordpress.com/2014/12/productranking.jpg?w=300&amp;h=244 300w, https://bartoszmilewski.files.wordpress.com/2014/12/productranking.jpg?w=150&amp;h=122 150w, https://bartoszmilewski.files.wordpress.com/2014/12/productranking.jpg 541w"></a><br>
Compare this with Fermat&#x2019;s principle of minimum time, or the principle of least action.</p>
<p>Conversely, contrast this with the traditional definition of a cartesian product, which is much more imperative. You describe how to create an element of the product by picking one element from one set and another element from another set. It&#x2019;s a recipe for creating a pair. And there&#x2019;s another for disassembling a pair.</p>
<p>In almost every programming language, including functional languages like Haskell, product types, coproduct types, and function types are built in, rather than being defined by universal constructions; although there have been attempts at creating categorical programming languages (see, e.g., Tatsuya Hagino&#x2019;s thesis in Bibliography). </p>
<p>Whether used directly or not, categorical definitions justify pre-existing programming constructs, and give rise to new ones. Most importantly, category theory provides a meta-language for reasoning about computer programs at a declarative level. It also encourages reasoning about problem specification before it is cast into code.</p>
<p>Next <a href="https://bartoszmilewski.com/2015/04/15/limits-and-colimits/">Limits and Colimits</a>.</p>
<h2>Acknowledgments</h2>
<p>I&#x2019;d like to thank Gershom Bazerman for checking my math and logic, and Andr&#xE9; van Meulebrouck, who has been volunteering his editing help.<br>
<a href="https://twitter.com/BartoszMilewski" class="twitter-follow-button">Follow @BartoszMilewski</a></p>
<h2>Bibliography</h2>
<ol>
<li>Tatsuya Hagino, <a href="http://web.sfc.keio.ac.jp/~hagino/thesis.pdf">A Categorical Programming Language</a>.</li>
</ol> <p id="geo-post-4415" class="geo"> <span class="latitude">43.193051</span> <span class="longitude">11.286150</span> </p> </div>