<div class="post-content"> <br><blockquote><p>This is part 19 of Categories for Programmers. Previously: <a href="https://bartoszmilewski.com/2016/04/18/adjunctions/">Adjunctions</a>. See the <a href="https://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/">Table of Contents</a>.</p></blockquote> <p>Free constructions are a powerful application of adjunctions. A <em>free functor</em> is defined as the left adjoint to a <em>forgetful functor</em>. A forgetful functor is usually a pretty simple functor that forgets some structure. For instance, lots of interesting categories are built on top of sets. But categorical objects, which abstract those sets, have no internal structure &#x2014; they have no elements. Still, those objects often carry the memory of sets, in the sense that there is a mapping &#x2014; a functor &#x2014; from a given category <i>C</i> to <b>Set</b>. A set corresponding to some object in <i>C</i> is called its <em>underlying set</em>.</p>
<p>Monoids are such objects that have underlying sets &#x2014; sets of elements. There is a forgetful functor <code>U</code> from the category of monoids <b>Mon</b> to the category of sets, which maps monoids to their underlying sets. It also maps monoid morphisms (homomorphisms) to functions between sets.</p>
<p>I like to think of <b>Mon</b> as having split personality. On the one hand, it&#x2019;s a bunch of sets with multiplication and unit elements. On the other hand, it&#x2019;s a category with featureless objects whose only structure is encoded in morphisms that go between them. Every set-function that preserves multiplication and unit gives rise to a morphism in <b>Mon</b>.</p>
<p>Things to keep in mind:</p>
<ul>
<li>There may be many monoids that map to the same set, and</li>
<li>There are fewer (or at most as many as) monoid morphisms than there are functions between their underlying sets.</li>
</ul>
<div id="attachment_5532" class="wp-caption alignnone"><a href="https://bartoszmilewski.files.wordpress.com/2016/05/forgetful.jpg"><img class="wp-image-5532" src="https://bartoszmilewski.files.wordpress.com/2016/05/forgetful.jpg?w=377&amp;h=234%20377w,%20https://bartoszmilewski.files.wordpress.com/2016/05/forgetful.jpg?w=754&amp;h=468%20754w,%20https://bartoszmilewski.files.wordpress.com/2016/05/forgetful.jpg?w=150&amp;h=93%20150w,%20https://bartoszmilewski.files.wordpress.com/2016/05/forgetful.jpg?w=300&amp;h=186%20300w" alt="Forgetful" width="377" srcset="https://bartoszmilewski.files.wordpress.com/2016/05/forgetful.jpg?w=377&amp;h=234 377w, https://bartoszmilewski.files.wordpress.com/2016/05/forgetful.jpg?w=754&amp;h=468 754w, https://bartoszmilewski.files.wordpress.com/2016/05/forgetful.jpg?w=150&amp;h=93 150w, https://bartoszmilewski.files.wordpress.com/2016/05/forgetful.jpg?w=300&amp;h=186 300w"></a><p class="wp-caption-text">Monoids m<sub>1</sub> and m<sub>2</sub> have the same underlying set. There are more functions between the underlying sets of m<sub>2</sub> and m<sub>3</sub> than there are morphisms between them.</p></div>
<p>The functor <code>F</code> that&#x2019;s the left adjoint to the forgetful functor <code>U</code> is the free functor that builds free monoids from their generator sets. The adjunction follows from the <a href="https://bartoszmilewski.com/2015/07/21/free-monoids/">free monoid universal construction</a> we&#x2019;ve discussed before.</p>
<p>In terms of hom-sets, we can write this adjunction as:</p>
<pre>Mon(F x, m) &#x2245; Set(x, U m)</pre>
<p>This (natural in <code>x</code> and <code>m</code>) isomorphism tells us that:</p>
<ul>
<li>For every monoid homomorphism between the free monoid <code>F x</code> generated by <code>x</code> and an arbitrary monoid <code>m</code> there is a unique function that embeds the set of generators <code>x</code> in the underlying set of <code>m</code>. It&#x2019;s a function in <code>Set(x, U m)</code>.</li>
<li>For every function that embeds <code>x</code> in the underlying set of some <code>m</code> there is a unique monoid morphism between the free monoid generated by <code>x</code> and the monoid <code>m</code>. (This is the morphism we called <code>h</code> in our universal construction.)</li>
</ul>
<p><a href="https://bartoszmilewski.files.wordpress.com/2016/05/freemonadjunction.jpg"><img class="alignnone wp-image-5534" src="https://bartoszmilewski.files.wordpress.com/2016/05/freemonadjunction.jpg?w=512&amp;h=203%20512w,%20https://bartoszmilewski.files.wordpress.com/2016/05/freemonadjunction.jpg?w=1022&amp;h=406%201022w,%20https://bartoszmilewski.files.wordpress.com/2016/05/freemonadjunction.jpg?w=150&amp;h=60%20150w,%20https://bartoszmilewski.files.wordpress.com/2016/05/freemonadjunction.jpg?w=300&amp;h=119%20300w,%20https://bartoszmilewski.files.wordpress.com/2016/05/freemonadjunction.jpg?w=768&amp;h=305%20768w" alt="FreeMonAdjunction" width="512" srcset="https://bartoszmilewski.files.wordpress.com/2016/05/freemonadjunction.jpg?w=512&amp;h=203 512w, https://bartoszmilewski.files.wordpress.com/2016/05/freemonadjunction.jpg?w=1022&amp;h=406 1022w, https://bartoszmilewski.files.wordpress.com/2016/05/freemonadjunction.jpg?w=150&amp;h=60 150w, https://bartoszmilewski.files.wordpress.com/2016/05/freemonadjunction.jpg?w=300&amp;h=119 300w, https://bartoszmilewski.files.wordpress.com/2016/05/freemonadjunction.jpg?w=768&amp;h=305 768w"></a></p>
<p>The intuition is that <code>F x</code> is the &#x201C;maximum&#x201D; monoid that can be built on the basis of <code>x</code>. If we could look inside monoids, we would see that any morphism that belongs to <code>Mon(F x, m)</code> <em>embeds</em> this free monoid in some other monoid <code>m</code>. It does it by possibly identifying some elements. In particular, it embeds the generators of <code>F x</code> (i.e., the elements of <code>x</code>) in <code>m</code>. The adjunction shows that the embedding of <code>x</code>, which is given by a function from <code>Set(x, U m)</code> on the right, uniquely determines the embedding of monoids on the left, and vice versa.</p>
<p>In Haskell, the list data structure is a free monoid (with some caveats: see <a href="http://comonad.com/reader/2015/free-monoids-in-haskell/">Dan Doel&#x2019;s blog post</a>). A list type <code>[a]</code> is a free monoid with the type <code>a</code> representing the set of generators. For instance, the type <code>[Char]</code> contains the unit element &#x2014; the empty list <code>[]</code> &#x2014; and the singletons like <code>[&apos;a&apos;]</code>, <code>[&apos;b&apos;]</code> &#x2014; the generators of the free monoid. The rest is generated by applying the &#x201C;product.&#x201D; Here, the product of two lists simply appends one to another. Appending is associative and unital (that is, there is a neutral element &#x2014; here, the empty list). A free monoid generated by <code>Char</code> is nothing but the set of all strings of characters from <code>Char</code>. It&#x2019;s called <code>String</code> in Haskell:</p>
<pre>type String = [Char]</pre>
<p>(<code>type</code> defines a type synonym &#x2014; a different name for an existing type).</p>
<p>Another interesting example is a free monoid built from just one generator. It&#x2019;s the type of the list of units, <code>[()]</code>. Its elements are <code>[]</code>, <code>[()]</code>, <code>[(), ()]</code>, etc. Every such list can be described by one natural number &#x2014; its length. There is no more information encoded in the list of units. Appending two such lists produces a new list whose length is the sum of the lengths of its constituents. It&#x2019;s easy to see that the type <code>[()]</code> is isomorphic to the additive monoid of natural numbers (with zero). Here are the two functions that are the inverse of each other, witnessing this isomorphism:</p>
<pre>toNat :: [()] -&gt; Int
toNat = length toLst :: Int -&gt; [()]
toLst n = replicate n ()</pre>
<p>For simplicity I used the type <code>Int</code> rather than <code>Natural</code>, but the idea is the same. The function <code>replicate</code> creates a list of length <code>n</code> pre-filled with a given value &#x2014; here, the unit.</p>
<h2>Some Intuitions</h2>
<p>What follows are some hand-waving arguments. Those kind of arguments are far from rigorous, but they help in forming intuitions.</p>
<p>To get some intuition about the free/forgetful adjunctions it helps to keep in mind that functors and functions are lossy in nature. Functors may collapse multiple objects and morphisms, functions may bunch together multiple elements of a set. Also, their image may cover only part of their codomain.</p>
<p>An &#x201C;average&#x201D; hom-set in <b>Set</b> will contain a whole spectrum of functions starting with the ones that are least lossy (e.g., injections or, possibly, isomorphisms) and ending with constant functions that collapse the whole domain to a single element (if there is one).</p>
<p>I tend to think of morphisms in an arbitrary category as being lossy too. It&#x2019;s just a mental model, but it&#x2019;s a useful one, especially when thinking of adjunctions &#x2014; in particular those in which one of the categories is <b>Set</b>.</p>
<p>Formally, we can only speak of morphisms that are invertible (isomorphisms) or non-invertible. It&#x2019;s that latter kind that may be though of as lossy. There is also a notion of mono- and epi- morphisms that generalize the idea of injective (non-collapsing) and surjective (covering the whole codomain) functions, but it&#x2019;s possible to have a morphism that is both mono and epi, and which is still non-invertible.</p>
<p>In the Free &#x22A3; Forgetful adjunction, we have the more constrained category <i>C</i> on the left, and a less constrained category <i>D</i> on the right. Morphisms in <i>C</i> are &#x201C;fewer&#x201D; because they have to preserve some additional structure. In the case of <b>Mon</b>, they have to preserve multiplication and unit. Morphisms in <i>D</i> don&#x2019;t have to preserve as much structure, so there are &#x201C;more&#x201D; of them.</p>
<p>When we apply a forgetful functor <code>U</code> to an object <code>c</code> in <i>C</i>, we think of it as revealing the &#x201C;internal structure&#x201D; of <code>c</code>. In fact, if <i>D</i> is <b>Set</b> we think of <code>U</code> as <em>defining</em> the internal structure of <code>c</code> &#x2014; its underlying set. (In an arbitrary category, we can&#x2019;t talk about the internals of an object other than through its connections to other objects, but here we are just hand-waving.)</p>
<p>If we map two objects <code>c&apos;</code> and <code>c</code> using <code>U</code>, we expect that, in general, the mapping of the hom-set <code>C(c&apos;, c)</code> will cover only a subset of <code>D(U c&apos;, U c)</code>. That&#x2019;s because morphisms in <code>C(c&apos;, c)</code> have to preserve the additional structure, whereas the ones in <code>D(U c&apos;, U c)</code> don&#x2019;t.</p>
<p><a href="https://bartoszmilewski.files.wordpress.com/2016/05/forgettingmorphisms.jpg"><img class="alignnone wp-image-5536" src="https://bartoszmilewski.files.wordpress.com/2016/05/forgettingmorphisms.jpg?w=413&amp;h=219%20413w,%20https://bartoszmilewski.files.wordpress.com/2016/05/forgettingmorphisms.jpg?w=826&amp;h=438%20826w,%20https://bartoszmilewski.files.wordpress.com/2016/05/forgettingmorphisms.jpg?w=150&amp;h=80%20150w,%20https://bartoszmilewski.files.wordpress.com/2016/05/forgettingmorphisms.jpg?w=300&amp;h=159%20300w,%20https://bartoszmilewski.files.wordpress.com/2016/05/forgettingmorphisms.jpg?w=768&amp;h=408%20768w" alt="ForgettingMorphisms" width="413" srcset="https://bartoszmilewski.files.wordpress.com/2016/05/forgettingmorphisms.jpg?w=413&amp;h=219 413w, https://bartoszmilewski.files.wordpress.com/2016/05/forgettingmorphisms.jpg?w=826&amp;h=438 826w, https://bartoszmilewski.files.wordpress.com/2016/05/forgettingmorphisms.jpg?w=150&amp;h=80 150w, https://bartoszmilewski.files.wordpress.com/2016/05/forgettingmorphisms.jpg?w=300&amp;h=159 300w, https://bartoszmilewski.files.wordpress.com/2016/05/forgettingmorphisms.jpg?w=768&amp;h=408 768w"></a></p>
<p>But since an adjunction is defined as an <em>isomporphism</em> of particular hom-sets, we have to be very picky with our selection of <code>c&apos;</code>. In the adjunction, <code>c&apos;</code> is picked not from just anywhere in <i>C</i>, but from the (presumably smaller) image of the free functor <code>F</code>:</p>
<pre>C(F d, c) &#x2245; D(d, U c)</pre>
<p>The image of <code>F</code> must therefore consist of objects that have lots of morphisms going to an arbitrary <code>c</code>. In fact, there has to be as many structure-preserving morphisms from <code>F d</code> to <code>c</code> as there are non-structure preserving morphisms from <code>d</code> to <code>U c</code>. It means that the image of <code>F</code> must consist of essentially structure-free objects (so that there is no structure to preserve by morphisms). Such &#x201C;structure-free&#x201D; objects are called free objects.</p>
<p><a href="https://bartoszmilewski.files.wordpress.com/2016/05/freeimage.jpg"><img class="alignnone wp-image-5537" src="https://bartoszmilewski.files.wordpress.com/2016/05/freeimage.jpg?w=422&amp;h=249%20422w,%20https://bartoszmilewski.files.wordpress.com/2016/05/freeimage.jpg?w=844&amp;h=498%20844w,%20https://bartoszmilewski.files.wordpress.com/2016/05/freeimage.jpg?w=150&amp;h=89%20150w,%20https://bartoszmilewski.files.wordpress.com/2016/05/freeimage.jpg?w=300&amp;h=177%20300w,%20https://bartoszmilewski.files.wordpress.com/2016/05/freeimage.jpg?w=768&amp;h=454%20768w" alt="FreeImage" width="422" srcset="https://bartoszmilewski.files.wordpress.com/2016/05/freeimage.jpg?w=422&amp;h=249 422w, https://bartoszmilewski.files.wordpress.com/2016/05/freeimage.jpg?w=844&amp;h=498 844w, https://bartoszmilewski.files.wordpress.com/2016/05/freeimage.jpg?w=150&amp;h=89 150w, https://bartoszmilewski.files.wordpress.com/2016/05/freeimage.jpg?w=300&amp;h=177 300w, https://bartoszmilewski.files.wordpress.com/2016/05/freeimage.jpg?w=768&amp;h=454 768w"></a></p>
<p>In the monoid example, a free monoid has no structure other than what&#x2019;s generated by unit and associativity laws. Other than that, all multiplications produce brand new elements.</p>
<p>In a free monoid, 2*3 is not 6 &#x2014; it&#x2019;s a new element [2, 3]. Since there is no identification of [2, 3] and 6, a morphism from this free monoid to any other monoid <code>m</code> is allowed to map them separately. But it&#x2019;s also okay for it to map both [2, 3] and 6 (their product) to the same element of <code>m</code>. Or to identify [2, 3] and 5 (their sum) in an additive monoid, and so on. Different identifications give you different monoids.</p>
<p>This leads to another interesting intuition: Free monoids, instead of performing the monoidal operation, accumulate the arguments that were passed to it. Instead of multiplying 2 and 3 they remember 2 and 3 in a list. The advantage of this scheme is that we don&#x2019;t have to specify what monoidal operation we will use. We can keep accumulating arguments, and only at the end apply an operator to the result. And it&#x2019;s then that we can chose what operator to apply. We can add the numbers, or multiply them, or perform addition modulo 2, and so on. A free monoid separates the creation of an expression from its evaluation. We&#x2019;ll see this idea again when we talk about algebras.</p>
<p>This intuition generalizes to other, more elaborate free constructions. For instance, we can accumulate whole expression trees before evaluating them. The advantage of this approach is that we can transform such trees to make the evaluation faster or less memory consuming. This is, for instance, done in implementing matrix calculus, where eager evaluation would lead to lots of allocations of temporary arrays to store intermediate results.</p>
<h2>Challenges</h2>
<ol>
<li>Consider a free monoid built from a singleton set as its generator. Show that there is a one-to-one correspondence between morphisms from this free monoid to any monoid <code>m</code>, and functions from the singleton set to the underlying set of <code>m</code>.</li>
</ol>
<p>Next: <a href="https://bartoszmilewski.com/2016/11/21/monads-programmers-definition/">Monads: Programmer&#x2019;s Definition</a>.</p>
<h2>Acknowledgments</h2>
<p>I&#x2019;d like to thank Gershom Bazerman for checking my math and logic, and Andr&#xE9; van Meulebrouck, who has been volunteering his editing help throughout this series of posts.<br>
<a href="https://twitter.com/BartoszMilewski" class="twitter-follow-button">Follow @BartoszMilewski</a></p> </div>