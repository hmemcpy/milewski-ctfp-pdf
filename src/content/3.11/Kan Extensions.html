<div class="post-content"> <br><blockquote><p>This is part 27 of Categories for Programmers. Previously: <a href="https://bartoszmilewski.com/2017/03/29/ends-and-coends/">Ends and Coends</a>. See the <a href="https://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/">Table of Contents</a>.</p></blockquote>
<p>So far we&#x2019;ve been mostly working with a single category or a pair of categories. In some cases that was a little too constraining. For instance, when defining a limit in a category <i>C</i>, we introduced an index category <code>I</code> as the template for the pattern that would form the basis for our cones. It would have made sense to introduce another category, a trivial one, to serve as a template for the apex of the cone. Instead we used the constant functor <code>&#x394;<sub>c</sub></code> from <code>I</code> to <code>C</code>.</p>
<p>It&#x2019;s time to fix this awkwardness. Let&#x2019;s define a limit using three categories. Let&#x2019;s start with the functor <code>D</code> from the index category <i>I</i> to <i>C</i>. This is the functor that selects the base of the cone &#x2014; the diagram functor.</p>
<p><a href="https://bartoszmilewski.files.wordpress.com/2017/04/kan2.jpg"><img class="alignnone wp-image-8641" src="https://bartoszmilewski.files.wordpress.com/2017/04/kan2.jpg?w=164&amp;h=141%20164w,%20https://bartoszmilewski.files.wordpress.com/2017/04/kan2.jpg?w=328&amp;h=282%20328w,%20https://bartoszmilewski.files.wordpress.com/2017/04/kan2.jpg?w=150&amp;h=129%20150w,%20https://bartoszmilewski.files.wordpress.com/2017/04/kan2.jpg?w=300&amp;h=258%20300w" alt="" width="164" srcset="https://bartoszmilewski.files.wordpress.com/2017/04/kan2.jpg?w=164&amp;h=141 164w, https://bartoszmilewski.files.wordpress.com/2017/04/kan2.jpg?w=328&amp;h=282 328w, https://bartoszmilewski.files.wordpress.com/2017/04/kan2.jpg?w=150&amp;h=129 150w, https://bartoszmilewski.files.wordpress.com/2017/04/kan2.jpg?w=300&amp;h=258 300w"></a></p>
<p>The new addition is the category <b>1</b> that contains a single object (and a single identity morphism). There is only one possible functor <code>K</code> from <i>I</i> to this category. It maps all objects to the only object in <b>1</b>, and all morphisms to the identity morphism. Any functor <code>F</code> from <b>1</b> to <i>C</i> picks a potential apex for our cone.</p>
<p><a href="https://bartoszmilewski.files.wordpress.com/2017/04/kan15.jpg"><img class="alignnone size-medium wp-image-8689" src="https://bartoszmilewski.files.wordpress.com/2017/04/kan15.jpg?w=300&amp;h=212%20300w,%20https://bartoszmilewski.files.wordpress.com/2017/04/kan15.jpg?w=150&amp;h=106%20150w,%20https://bartoszmilewski.files.wordpress.com/2017/04/kan15.jpg%20537w" alt="" width="300" srcset="https://bartoszmilewski.files.wordpress.com/2017/04/kan15.jpg?w=300&amp;h=212 300w, https://bartoszmilewski.files.wordpress.com/2017/04/kan15.jpg?w=150&amp;h=106 150w, https://bartoszmilewski.files.wordpress.com/2017/04/kan15.jpg 537w"></a></p>
<p>A cone is a natural transformation <code>&#x3B5;</code> from <code>F &#x2218; K</code> to <code>D</code>. Notice that <code>F &#x2218; K</code> does exactly the same thing as our original <code>&#x394;<sub>c</sub></code>. The following diagram shows this transformation.</p>
<p><a href="https://bartoszmilewski.files.wordpress.com/2017/04/kan3-e1492120491591.jpg"><img class="alignnone wp-image-8642" src="https://bartoszmilewski.files.wordpress.com/2017/04/kan3-e1492120491591.jpg?w=222&amp;h=150%20222w,%20https://bartoszmilewski.files.wordpress.com/2017/04/kan3-e1492120491591.jpg?w=150&amp;h=101%20150w,%20https://bartoszmilewski.files.wordpress.com/2017/04/kan3-e1492120491591.jpg?w=300&amp;h=202%20300w,%20https://bartoszmilewski.files.wordpress.com/2017/04/kan3-e1492120491591.jpg%20441w" alt="" width="222" srcset="https://bartoszmilewski.files.wordpress.com/2017/04/kan3-e1492120491591.jpg?w=222&amp;h=150 222w, https://bartoszmilewski.files.wordpress.com/2017/04/kan3-e1492120491591.jpg?w=150&amp;h=101 150w, https://bartoszmilewski.files.wordpress.com/2017/04/kan3-e1492120491591.jpg?w=300&amp;h=202 300w, https://bartoszmilewski.files.wordpress.com/2017/04/kan3-e1492120491591.jpg 441w"></a></p>
<p>We can now define a universal property that picks the &#x201C;best&#x201D; such functor <code>F</code>. This <code>F</code> will map <b>1</b> to the object that is the limit of <code>D</code> in <i>C</i>, and the natural transformation <code>&#x3B5;</code> from <code>F &#x2218; K</code> to <code>D</code> will provide the corresponding projections. This universal functor is called the right Kan extension of <code>D</code> along <code>K</code> and is denoted by <code>Ran<sub>K</sub>D</code>.</p>
<p>Let&#x2019;s formulate the universal property. Suppose we have another cone &#x2014; that is another functor <code>F&apos;</code> together with a natural transformation <code>&#x3B5;&apos;</code> from <code>F&apos; &#x2218; K</code> to <code>D</code>.</p>
<p><a href="https://bartoszmilewski.files.wordpress.com/2017/04/kan31-e1492120512209.jpg"><img class="alignnone wp-image-8663" src="https://bartoszmilewski.files.wordpress.com/2017/04/kan31-e1492120512209.jpg?w=227&amp;h=165%20227w,%20https://bartoszmilewski.files.wordpress.com/2017/04/kan31-e1492120512209.jpg?w=150&amp;h=109%20150w,%20https://bartoszmilewski.files.wordpress.com/2017/04/kan31-e1492120512209.jpg?w=300&amp;h=218%20300w,%20https://bartoszmilewski.files.wordpress.com/2017/04/kan31-e1492120512209.jpg%20420w" alt="" width="227" srcset="https://bartoszmilewski.files.wordpress.com/2017/04/kan31-e1492120512209.jpg?w=227&amp;h=165 227w, https://bartoszmilewski.files.wordpress.com/2017/04/kan31-e1492120512209.jpg?w=150&amp;h=109 150w, https://bartoszmilewski.files.wordpress.com/2017/04/kan31-e1492120512209.jpg?w=300&amp;h=218 300w, https://bartoszmilewski.files.wordpress.com/2017/04/kan31-e1492120512209.jpg 420w"></a></p>
<p>If the Kan extension <code>F = Ran<sub>K</sub>D</code> exists, there must be a unique natural transformation <code>&#x3C3;</code> from <code>F&apos;</code> to it, such that <code>&#x3B5;&apos;</code> factorizes through <code>&#x3B5;</code>, that is:</p>
<pre>&#x3B5;&apos; = &#x3B5; . (&#x3C3; &#x2218; K)</pre>
<p>Here, <code>&#x3C3; &#x2218; K</code> is the horizontal composition of two natural transformations (one of them being the identity natural transformation on <code>K</code>). This transformation is then vertically composed with <code>&#x3B5;</code>.</p>
<p><a href="https://bartoszmilewski.files.wordpress.com/2017/04/kan5.jpg"><img class="alignnone wp-image-8644" src="https://bartoszmilewski.files.wordpress.com/2017/04/kan5.jpg?w=237&amp;h=178%20237w,%20https://bartoszmilewski.files.wordpress.com/2017/04/kan5.jpg?w=474&amp;h=356%20474w,%20https://bartoszmilewski.files.wordpress.com/2017/04/kan5.jpg?w=150&amp;h=112%20150w,%20https://bartoszmilewski.files.wordpress.com/2017/04/kan5.jpg?w=300&amp;h=225%20300w" alt="" width="237" srcset="https://bartoszmilewski.files.wordpress.com/2017/04/kan5.jpg?w=237&amp;h=178 237w, https://bartoszmilewski.files.wordpress.com/2017/04/kan5.jpg?w=474&amp;h=356 474w, https://bartoszmilewski.files.wordpress.com/2017/04/kan5.jpg?w=150&amp;h=112 150w, https://bartoszmilewski.files.wordpress.com/2017/04/kan5.jpg?w=300&amp;h=225 300w"></a></p>
<p>In components, when acting on an object <code>i</code> in <i>I</i>, we get:</p>
<pre>&#x3B5;&apos;<sub>i</sub> = &#x3B5;<sub>i</sub> &#x2218; &#x3C3;<sub> K i</sub></pre>
<p>In our case, <code>&#x3C3;</code> has only one component corresponding to the single object of <b>1</b>. So, indeed, this is the unique morphism from the apex of the cone defined by <code>F&apos;</code> to the apex of the universal cone defined by <code>Ran<sub>K</sub>D</code>. The commuting conditions are exactly the ones required by the definition of a limit.</p>
<p>But, importantly, we are free to replace the trivial category <b>1</b> with an arbitrary category <i>A</i>, and the definition of the right Kan extension remains valid.</p>
<h2>Right Kan Extension</h2>
<p>The right Kan extension of the functor <code>D::I-&gt;C</code> along the functor <code>K::I-&gt;A</code> is a functor <code>F::A-&gt;C</code> (denoted <code>Ran<sub>K</sub>D</code>) together with a natural transformation</p>
<pre>&#x3B5; :: F &#x2218; K -&gt; D</pre>
<p>such that for any other functor <code>F&apos;::A-&gt;C</code> and a natural transformation</p>
<pre>&#x3B5;&apos; :: F&apos; &#x2218; K -&gt; D</pre>
<p>there is a unique natural transformation</p>
<pre>&#x3C3; :: F&apos; -&gt; F</pre>
<p>that factorizes <code>&#x3B5;&apos;</code>:</p>
<pre>&#x3B5;&apos; = &#x3B5; . (&#x3C3; &#x2218; K)</pre>
<p>This is quite a mouthful, but it can be visualized in this nice diagram:</p>
<p><a href="https://bartoszmilewski.files.wordpress.com/2017/04/kan7.jpg"><img class="alignnone wp-image-8646" src="https://bartoszmilewski.files.wordpress.com/2017/04/kan7.jpg?w=188&amp;h=180%20188w,%20https://bartoszmilewski.files.wordpress.com/2017/04/kan7.jpg?w=376&amp;h=360%20376w,%20https://bartoszmilewski.files.wordpress.com/2017/04/kan7.jpg?w=150&amp;h=143%20150w,%20https://bartoszmilewski.files.wordpress.com/2017/04/kan7.jpg?w=300&amp;h=287%20300w" alt="" width="188" srcset="https://bartoszmilewski.files.wordpress.com/2017/04/kan7.jpg?w=188&amp;h=180 188w, https://bartoszmilewski.files.wordpress.com/2017/04/kan7.jpg?w=376&amp;h=360 376w, https://bartoszmilewski.files.wordpress.com/2017/04/kan7.jpg?w=150&amp;h=143 150w, https://bartoszmilewski.files.wordpress.com/2017/04/kan7.jpg?w=300&amp;h=287 300w"></a></p>
<p>An interesting way of looking at this is to notice that, in a sense, the Kan extension acts like the inverse of &#x201C;functor multiplication.&#x201D; Some authors go as far as use the notation <code>D/K</code> for <code>Ran<sub>K</sub>D</code>. Indeed, in this notation, the definition of <code>&#x3B5;</code>, which is also called the counit of the right Kan extension, looks like simple cancellation:</p>
<pre>&#x3B5; :: D/K &#x2218; K -&gt; D</pre>
<p>There is another interpretation of Kan extensions. Consider that the functor <code>K</code> embeds the category <i>I</i> inside <i>A</i>. In the simplest case <i>I</i> could just be a subcategory of <i>A</i>. We have a functor <code>D</code> that maps <i>I</i> to <i>C</i>. Can we extend <code>D</code> to a functor <code>F</code> that is defined on the whole of <i>A</i>? Ideally, such an extension would make the composition <code>F &#x2218; K</code> be isomorphic to <code>D</code>. In other words, <code>F</code> would be extending the domain of <code>D</code> to <code>A</code>. But a full-blown isomorphism is usually too much to ask, and we can do with just half of it, namely a one-way natural transformation <code>&#x3B5;</code> from <code>F &#x2218; K</code> to <code>D</code>. (The left Kan extension picks the other direction.)</p>
<p><a href="https://bartoszmilewski.files.wordpress.com/2017/04/kan6.jpg"><img class="alignnone size-medium wp-image-8645" src="https://bartoszmilewski.files.wordpress.com/2017/04/kan6.jpg?w=300&amp;h=168%20300w,%20https://bartoszmilewski.files.wordpress.com/2017/04/kan6.jpg?w=150&amp;h=84%20150w,%20https://bartoszmilewski.files.wordpress.com/2017/04/kan6.jpg%20530w" alt="" width="300" srcset="https://bartoszmilewski.files.wordpress.com/2017/04/kan6.jpg?w=300&amp;h=168 300w, https://bartoszmilewski.files.wordpress.com/2017/04/kan6.jpg?w=150&amp;h=84 150w, https://bartoszmilewski.files.wordpress.com/2017/04/kan6.jpg 530w"></a><br>
Of course, the embedding picture breaks down when the functor <code>K</code> is not injective on objects or not faithful on hom-sets, as in the example of the limit. In that case, the Kan extension tries its best to extrapolate the lost information.</p>
<h2>Kan Extension as Adjunction</h2>
<p>Now suppose that the right Kan extension exists for any <code>D</code> (and a fixed <code>K</code>). In that case <code>Ran<sub>K </sub>-</code> (with the dash replacing <code>D</code>) is a functor from the functor category <code>[I, C]</code> to the functor category <code>[A, C]</code>. It turns out that this functor is the right adjoint to the precomposition functor <code>-&#x2218;K</code>. The latter maps functors in <code>[A, C]</code> to functors in <code>[I, C]</code>. The adjunction is:</p>
<pre>[I, C](F&apos; &#x2218; K, D) &#x2245; [A, C](F&apos;, Ran<sub>K</sub>D)</pre>
<p>It is just a restatement of the fact that to every natural transformation we called <code>&#x3B5;&apos;</code> corresponds a unique natural transformation we called <code>&#x3C3;</code>.</p>
<p><a href="https://bartoszmilewski.files.wordpress.com/2017/04/kan92.jpg"><img class="alignnone size-medium wp-image-8700" src="https://bartoszmilewski.files.wordpress.com/2017/04/kan92.jpg?w=300&amp;h=238%20300w,%20https://bartoszmilewski.files.wordpress.com/2017/04/kan92.jpg?w=600&amp;h=476%20600w,%20https://bartoszmilewski.files.wordpress.com/2017/04/kan92.jpg?w=150&amp;h=119%20150w" alt="" width="300" srcset="https://bartoszmilewski.files.wordpress.com/2017/04/kan92.jpg?w=300&amp;h=238 300w, https://bartoszmilewski.files.wordpress.com/2017/04/kan92.jpg?w=600&amp;h=476 600w, https://bartoszmilewski.files.wordpress.com/2017/04/kan92.jpg?w=150&amp;h=119 150w"></a></p>
<p>Furthermore, if we chose the category <i>I</i> to be the same as <i>C</i>, we can substitute the identity functor <code>I<sub>C</sub></code> for <code>D</code>. We get the following identity:</p>
<pre>[C, C](F&apos; &#x2218; K, I<sub>C</sub>) &#x2245; [A, C](F&apos;, Ran<sub>K</sub>I<sub>C</sub>)</pre>
<p>We can now chose <code>F&apos;</code> to be the same as <code>Ran<sub>K</sub>I<sub>C</sub></code>. In that case the right hand side contains the identity natural transformation and, corresponding to it, the left hand side gives us the following natural transformation:</p>
<pre>&#x3B5; :: Ran<sub>K</sub>I<sub>C</sub> &#x2218; K -&gt; I<sub>C</sub></pre>
<p>This looks very much like the counit of an adjunction:</p>
<pre>Ran<sub>K</sub>I<sub>C</sub> &#x22A3; K</pre>
<p>Indeed, the right Kan extension of the identity functor along a functor <code>K</code> can be used to calculate the left adjoint of <code>K</code>. For that, one more condition is necessary: the right Kan extension must be preserved by the functor <code>K</code>. The preservation of the extension means that, if we calculate the Kan extension of the functor precomposed with <code>K</code>, we should get the same result as precomposing the original Kan extesion with <code>K</code>. In our case, this condition simplifies to:</p>
<pre>K &#x2218; Ran<sub>K</sub>I<sub>C</sub> &#x2245; Ran<sub>K</sub>K</pre>
<p>Notice that, using the division-by-K notation, the adjunction can be written as:</p>
<pre>I/K &#x22A3; K</pre>
<p>which confirms our intuition that an adjunction describes some kind of an inverse. The preservation condition becomes:</p>
<pre>K &#x2218; I/K &#x2245; K/K</pre>
<p>The right Kan extension of a functor along itself, <code>K/K</code>, is called a codensity monad.</p>
<p>The adjunction formula is an important result because, as we&#x2019;ll see soon, we can calculate Kan extensions using ends (coends), thus giving us practical means of finding right (and left) adjoints.</p>
<h2>Left Kan Extension</h2>
<p>There is a dual construction that gives us the left Kan extension. To build some intuition, we&#x2019;ll can start with the definition of a colimit and restructure it to use the singleton category <b>1</b>. We build a cocone by using the functor <code>D::I-&gt;C</code> to form its base, and the functor <code>F::1-&gt;C</code> to select its apex.</p>
<p><a href="https://bartoszmilewski.files.wordpress.com/2017/04/kan81.jpg"><img class="alignnone wp-image-8654" src="https://bartoszmilewski.files.wordpress.com/2017/04/kan81.jpg?w=183&amp;h=138%20183w,%20https://bartoszmilewski.files.wordpress.com/2017/04/kan81.jpg?w=364&amp;h=276%20364w,%20https://bartoszmilewski.files.wordpress.com/2017/04/kan81.jpg?w=150&amp;h=114%20150w,%20https://bartoszmilewski.files.wordpress.com/2017/04/kan81.jpg?w=300&amp;h=227%20300w" alt="" width="183" srcset="https://bartoszmilewski.files.wordpress.com/2017/04/kan81.jpg?w=183&amp;h=138 183w, https://bartoszmilewski.files.wordpress.com/2017/04/kan81.jpg?w=364&amp;h=276 364w, https://bartoszmilewski.files.wordpress.com/2017/04/kan81.jpg?w=150&amp;h=114 150w, https://bartoszmilewski.files.wordpress.com/2017/04/kan81.jpg?w=300&amp;h=227 300w"></a></p>
<p>The sides of the cocone, the injections, are components of a natural transformation <code>&#x3B7;</code> from <code>D</code> to <code>F &#x2218; K</code>.</p>
<p><a href="https://bartoszmilewski.files.wordpress.com/2017/04/kan10a.jpg"><img class="alignnone wp-image-8679" src="https://bartoszmilewski.files.wordpress.com/2017/04/kan10a.jpg?w=224&amp;h=117%20224w,%20https://bartoszmilewski.files.wordpress.com/2017/04/kan10a.jpg?w=150&amp;h=78%20150w,%20https://bartoszmilewski.files.wordpress.com/2017/04/kan10a.jpg?w=300&amp;h=157%20300w,%20https://bartoszmilewski.files.wordpress.com/2017/04/kan10a.jpg%20411w" alt="" width="224" srcset="https://bartoszmilewski.files.wordpress.com/2017/04/kan10a.jpg?w=224&amp;h=117 224w, https://bartoszmilewski.files.wordpress.com/2017/04/kan10a.jpg?w=150&amp;h=78 150w, https://bartoszmilewski.files.wordpress.com/2017/04/kan10a.jpg?w=300&amp;h=157 300w, https://bartoszmilewski.files.wordpress.com/2017/04/kan10a.jpg 411w"></a></p>
<p>The colimit is the universal cocone. So for any other functor <code>F&apos;</code> and a natural transformation</p>
<pre>&#x3B7;&apos; :: D -&gt; F&apos;&#x2218; K</pre>
<p><a href="https://bartoszmilewski.files.wordpress.com/2017/04/kan10b.jpg"><img class="alignnone wp-image-8680" src="https://bartoszmilewski.files.wordpress.com/2017/04/kan10b.jpg?w=231&amp;h=120%20231w,%20https://bartoszmilewski.files.wordpress.com/2017/04/kan10b.jpg?w=150&amp;h=78%20150w,%20https://bartoszmilewski.files.wordpress.com/2017/04/kan10b.jpg?w=300&amp;h=156%20300w,%20https://bartoszmilewski.files.wordpress.com/2017/04/kan10b.jpg%20418w" alt="" width="231" srcset="https://bartoszmilewski.files.wordpress.com/2017/04/kan10b.jpg?w=231&amp;h=120 231w, https://bartoszmilewski.files.wordpress.com/2017/04/kan10b.jpg?w=150&amp;h=78 150w, https://bartoszmilewski.files.wordpress.com/2017/04/kan10b.jpg?w=300&amp;h=156 300w, https://bartoszmilewski.files.wordpress.com/2017/04/kan10b.jpg 418w"></a></p>
<p>there is a unique natural transformation <code>&#x3C3;</code> from <code>F</code> to <code>F&apos;</code></p>
<p><a href="https://bartoszmilewski.files.wordpress.com/2017/04/kan14.jpg"><img class="alignnone wp-image-8656" src="https://bartoszmilewski.files.wordpress.com/2017/04/kan14.jpg?w=200&amp;h=161%20200w,%20https://bartoszmilewski.files.wordpress.com/2017/04/kan14.jpg?w=400&amp;h=322%20400w,%20https://bartoszmilewski.files.wordpress.com/2017/04/kan14.jpg?w=150&amp;h=120%20150w,%20https://bartoszmilewski.files.wordpress.com/2017/04/kan14.jpg?w=300&amp;h=241%20300w" alt="" width="200" srcset="https://bartoszmilewski.files.wordpress.com/2017/04/kan14.jpg?w=200&amp;h=161 200w, https://bartoszmilewski.files.wordpress.com/2017/04/kan14.jpg?w=400&amp;h=322 400w, https://bartoszmilewski.files.wordpress.com/2017/04/kan14.jpg?w=150&amp;h=120 150w, https://bartoszmilewski.files.wordpress.com/2017/04/kan14.jpg?w=300&amp;h=241 300w"></a></p>
<p>such that:</p>
<pre>&#x3B7;&apos; = (&#x3C3; &#x2218; K) . &#x3B7;</pre>
<p>This is illustrated in the following diagram:<br>
<a href="https://bartoszmilewski.files.wordpress.com/2017/04/kan112.jpg"><img class="alignnone wp-image-8681" src="https://bartoszmilewski.files.wordpress.com/2017/04/kan112.jpg?w=211&amp;h=164%20211w,%20https://bartoszmilewski.files.wordpress.com/2017/04/kan112.jpg?w=422&amp;h=328%20422w,%20https://bartoszmilewski.files.wordpress.com/2017/04/kan112.jpg?w=150&amp;h=117%20150w,%20https://bartoszmilewski.files.wordpress.com/2017/04/kan112.jpg?w=300&amp;h=233%20300w" alt="" width="211" srcset="https://bartoszmilewski.files.wordpress.com/2017/04/kan112.jpg?w=211&amp;h=164 211w, https://bartoszmilewski.files.wordpress.com/2017/04/kan112.jpg?w=422&amp;h=328 422w, https://bartoszmilewski.files.wordpress.com/2017/04/kan112.jpg?w=150&amp;h=117 150w, https://bartoszmilewski.files.wordpress.com/2017/04/kan112.jpg?w=300&amp;h=233 300w"></a></p>
<p>Replacing the singleton category <b>1</b> with <i>A</i>, this definition naturally generalized to the definition of the left Kan extension, denoted by <code>Lan<sub>K</sub>D</code>.<br>
<a href="https://bartoszmilewski.files.wordpress.com/2017/04/kan12.jpg"><img class="alignnone wp-image-8651" src="https://bartoszmilewski.files.wordpress.com/2017/04/kan12.jpg?w=198&amp;h=159%20198w,%20https://bartoszmilewski.files.wordpress.com/2017/04/kan12.jpg?w=396&amp;h=318%20396w,%20https://bartoszmilewski.files.wordpress.com/2017/04/kan12.jpg?w=150&amp;h=120%20150w,%20https://bartoszmilewski.files.wordpress.com/2017/04/kan12.jpg?w=300&amp;h=241%20300w" alt="" width="198" srcset="https://bartoszmilewski.files.wordpress.com/2017/04/kan12.jpg?w=198&amp;h=159 198w, https://bartoszmilewski.files.wordpress.com/2017/04/kan12.jpg?w=396&amp;h=318 396w, https://bartoszmilewski.files.wordpress.com/2017/04/kan12.jpg?w=150&amp;h=120 150w, https://bartoszmilewski.files.wordpress.com/2017/04/kan12.jpg?w=300&amp;h=241 300w"></a><br>
The natural transformation:</p>
<pre>&#x3B7; :: D -&gt; Lan<sub>K</sub>D &#x2218; K</pre>
<p>is called the unit of the left Kan extension.</p>
<p>As before, we can recast the one-to-one correspondence between natural transformations:</p>
<pre>&#x3B7;&apos; = (&#x3C3; &#x2218; K) . &#x3B7;</pre>
<p>in terms of the adjunction:</p>
<pre>[A, C](Lan<sub>K</sub>D, F&apos;) &#x2245; [I, C](D, F&apos; &#x2218; K)</pre>
<p>In other words, the left Kan extension is the left adjoint, and the right Kan extension is the right adjoint of the postcomposition with <code>K</code>.</p>
<p>Just like the right Kan extension of the identity functor could be used to calculate the left adjoint of <code>K</code>, the left Kan extension of the identity functor turns out to be the right adjoint of <code>K</code> (with <code>&#x3B7;</code> being the unit of&#xA0; the adjunction):</p>
<pre>K &#x22A3; Lan<sub>K</sub>I<sub>C</sub></pre>
<p>Combining the two results, we get:</p>
<pre>Ran<sub>K</sub>I<sub>C</sub> &#x22A3; K &#x22A3; Lan<sub>K</sub>I<sub>C</sub></pre>
<h2>Kan Extensions as Ends</h2>
<p>The real power of Kan extensions comes from the fact that they can be calculated using ends (and coends). For simplicity, we&#x2019;ll restrict our attention to the case where the target category <i>C</i> is <b>Set</b>, but the formulas can be extended to any category.</p>
<p>Let&#x2019;s revisit the idea that a Kan extension can be used to extend the action of a functor outside of its original domain. Suppose that <code>K</code> embeds <i>I</i> inside <i>A</i>. Functor <code>D</code> maps <i>I</i> to <b>Set</b>. We could just say that for any object <code>a</code> in the image of <code>K</code>, that is <code>a = K i</code>, the extended functor maps <code>a</code> to <code>D i</code>. The problem is, what to do with those objects in <i>A</i> that are outside of the image of <code>K</code>? The idea is that every such object is potentially connected through lots of morphisms to every object in the image of <code>K</code>. A functor must preserve these morphisms. The totality of morphisms from an object <code>a</code> to the image of <code>K</code> is characterized by the hom-functor:</p>
<pre>A(a, K -)</pre>
<p><a href="https://bartoszmilewski.files.wordpress.com/2017/04/kan13.jpg"><img class="alignnone size-medium wp-image-8652" src="https://bartoszmilewski.files.wordpress.com/2017/04/kan13.jpg?w=300&amp;h=183%20300w,%20https://bartoszmilewski.files.wordpress.com/2017/04/kan13.jpg?w=150&amp;h=92%20150w,%20https://bartoszmilewski.files.wordpress.com/2017/04/kan13.jpg%20597w" alt="" width="300" srcset="https://bartoszmilewski.files.wordpress.com/2017/04/kan13.jpg?w=300&amp;h=183 300w, https://bartoszmilewski.files.wordpress.com/2017/04/kan13.jpg?w=150&amp;h=92 150w, https://bartoszmilewski.files.wordpress.com/2017/04/kan13.jpg 597w"></a><br>
Notice that this hom-functor is a composition of two functors:</p>
<pre>A(a, K -) = A(a, -) &#x2218; K</pre>
<p>The right Kan extension is the right adjoint of functor composition:</p>
<pre>[I, Set](F&apos; &#x2218; K, D) &#x2245; [A, Set](F&apos;, Ran<sub>K</sub>D)</pre>
<p>Let&#x2019;s see what happens when we replace <code>F&apos;</code> with the hom functor:</p>
<pre>[I, Set](A(a, -) &#x2218; K, D) &#x2245; [A, Set](A(a, -), Ran<sub>K</sub>D)</pre>
<p>and then inline the composition:</p>
<pre>[I, Set](A(a, K -), D) &#x2245; [A, Set](A(a, -), Ran<sub>K</sub>D)</pre>
<p>The right hand side can be reduced using the Yoneda lemma:</p>
<pre>[I, Set](A(a, K -), D) &#x2245; Ran<sub>K</sub>D a</pre>
<p>We can now rewrite the set of natural transformations as the end to get this very convenient formula for the right Kan extension:</p>
<pre>Ran<sub>K</sub>D a &#x2245; &#x222B;<sub>i</sub> Set(A(a, K i), D i)</pre>
<p>There is an analogous formula for the left Kan extension in terms of a coend:</p>
<pre>Lan<sub>K</sub>D a = &#x222B;<sup>i</sup> A(K i, a) &#xD7; D i</pre>
<p>To see that this is the case, we&#x2019;ll show that this is indeed the left adjoint to functor composition:</p>
<pre>[A, Set](Lan<sub>K</sub>D, F&apos;) &#x2245; [I, Set](D, F&apos;&#x2218; K)</pre>
<p>Let&#x2019;s substitute our formula in the left hand side:</p>
<pre>[A, Set](&#x222B;<sup>i</sup> A(K i, -) &#xD7; D i, F&apos;)</pre>
<p>This is a set of natural transformations, so it can be rewritten as an end:</p>
<pre>&#x222B;<sub>a</sub> Set(&#x222B;<sup>i</sup> A(K i, a) &#xD7; D i, F&apos;a)</pre>
<p>Using the continuity of the hom-functor, we can replace the coend with the end:</p>
<pre>&#x222B;<sub>a</sub> &#x222B;<sub>i</sub> Set(A(K i, a) &#xD7; D i, F&apos;a)</pre>
<p>We can use the product-exponential adjunction:</p>
<pre>&#x222B;<sub>a</sub> &#x222B;<sub>i</sub> Set(A(K i, a), (F&apos;a)<sup>D i</sup>)</pre>
<p>The exponential is isomorphic to the corresponding hom-set:</p>
<pre>&#x222B;<sub>a</sub> &#x222B;<sub>i</sub> Set(A(K i, a), A(D i, F&apos;a))</pre>
<p>There is a theorem called the Fubini theorem that allows us to swap the two ends:</p>
<pre>&#x222B;<sub>i</sub> &#x222B;<sub>a</sub> Set(A(K i, a), A(D i, F&apos;a))</pre>
<p>The inner end represents the set of natural transformations between two functors, so we can use the Yoneda lemma:</p>
<pre>&#x222B;<sub>i</sub> A(D i, F&apos;(K i))</pre>
<p>This is indeed the set of natural transformations that forms the right hand side of the adjunction we set out to prove:</p>
<pre>[I, Set](D, F&apos;&#x2218; K)</pre>
<p>These kinds of calculations using ends, coends, and the Yoneda lemma are pretty typical for the &#x201C;calculus&#x201D; of ends.</p>
<h2>Kan Extensions in Haskell</h2>
<p>The end/coend formulas for Kan extensions can be easily translated to Haskell. Let&#x2019;s start with the right extension:</p>
<pre>Ran<sub>K</sub>D a &#x2245; &#x222B;<sub>i</sub> Set(A(a, K i), D i)</pre>
<p>We replace the end with the universal quantifier, and hom-sets with function types:</p>
<pre>newtype Ran k d a = Ran (forall i. (a -&gt; k i) -&gt; d i)</pre>
<p>Looking at this definition, it&#x2019;s clear that <code>Ran</code> must contain a value of type <code>a</code> to which the function can be applied, and a natural transformation between the two functors <code>k</code> and <code>d</code>. For instance, suppose that <code>k</code> is the tree functor, and <code>d</code> is the list functor, and you were given a <code>Ran Tree [] String</code>. If you pass it a function:</p>
<pre>f :: String -&gt; Tree Int</pre>
<p>you&#x2019;ll get back a list of <code>Int</code>, and so on. The right Kan extension will use your function to produce a tree and then repackage it into a list. For instance, you may pass it a parser that generates a parsing tree from a string, and you&#x2019;ll get a list that corresponds to the depth-first traversal of this tree.</p>
<p>The right Kan extension can be used to calculate the left adjoint of a given functor by replacing the functor <code>d</code> with the identity functor. This leads to the left adjoint of a functor <code>k</code> being represented by the set of polymorphic functions of the type:</p>
<pre>forall i. (a -&gt; k i) -&gt; i</pre>
<p>Suppose that <code>k</code> is the forgetful functor from the category of monoids. The universal quantifier then goes over all monoids. Of course, in Haskell we cannot express monoidal laws, but the following is a decent approximation of the resulting free functor (the forgetful functor <code>k</code> is an identity on objects):</p>
<pre>type Lst a = forall i. Monoid i =&gt; (a -&gt; i) -&gt; i</pre>
<p>As expected, it generates free monoids, or Haskell lists:</p>
<pre>toLst :: [a] -&gt; Lst a toLst as = \f -&gt; foldMap f as fromLst :: Lst a -&gt; [a] fromLst f = f (\a -&gt; [a])</pre>
<p>The left Kan extension is a coend:</p>
<pre>Lan<sub>K</sub>D a = &#x222B;<sup>i</sup> A(K i, a) &#xD7; D i</pre>
<p>so it translates to an existential quantifier. Symbolically:</p>
<pre>Lan k d a = exists i. (k i -&gt; a, d i)</pre>
<p>This can be encoded in Haskell using GADTs, or using a universally quantified data constructor:</p>
<pre>data Lan k d a = forall i. Lan (k i -&gt; a) (d i)</pre>
<p>The interpretation of this data structure is that it contains a function that takes a container of some unspecified <code>i</code>s and produces an <code>a</code>. It also has a container of those <code>i</code>s. Since you have no idea what <code>i</code>s are, the only thing you can do with this data structure is to retrieve the container of <code>i</code>s, repack it into the container defined by the functor <code>k</code> using a natural transformation, and call the function to obtain the <code>a</code>. For instance, if <code>d</code> is a tree, and <code>k</code> is a list, you can serialize the tree, call the function with the resulting list, and obtain an <code>a</code>.</p>
<p>The left Kan extension can be used to calculate the right adjoint of a functor. We know that the right adjoint of the product functor is the exponential, so let&#x2019;s try to implement it using the Kan extension:</p>
<pre>type Exp a b = Lan ((,) a) I b</pre>
<p>This is indeed isomorphic to the function type, as witnessed by the following pair of functions:</p>
<pre>toExp :: (a -&gt; b) -&gt; Exp a b toExp f = Lan (f . fst) (I ()) fromExp :: Exp a b -&gt; (a -&gt; b) fromExp (Lan f (I x)) = \a -&gt; f (a, x)</pre>
<p>Notice that, as described earlier in the general case, we performed the following steps: (1) retrieved the container of <code>x</code> (here, it&#x2019;s just a trivial identity container), and the function <code>f</code>, (2) repackaged the container using the natural transformation between the identity functor and the pair functor, and (3) called the function <code>f</code>.</p>
<h2>Free Functor</h2>
<p>An interesting application of Kan extensions is the construction of a free functor. It&#x2019;s the solution to the following practical problem: suppose you have a type constructor &#x2014; that is a mapping of objects. Is it possible to define a functor based on this type constructor? In other words, can we define a mapping of morphisms that would extend this type constructor to a full-blown endofunctor? </p>
<p>The key observation is that a type constructor can be described as a functor whose domain is a discrete category. A discrete category has no morphisms other than the identity morphisms. Given a category <i>C</i>, we can always construct a discrete category <i>|C|</i> by simply discarding all non-identity morphisms. A functor <code>F</code> from <i>|C|</i> to <i>C</i> is then a simple mapping of objects, or what we call a type constructor in Haskell. There is also a canonical functor <code>J</code> that injects <i>|C|</i> into <i>C</i>: it&#x2019;s an identity on objects (and on identity morphisms). The left Kan extension of <code>F</code> along <code>J</code>, if it exists, is then a functor for <i>C</i> to <i>C</i>:</p>
<pre>Lan<sub>J</sub> F a = &#x222B;<sup>i</sup> C(J i, a) &#xD7; F i</pre>
<p>It&#x2019;s called a free functor based on <code>F</code>. </p>
<p>In Haskell, we would write it as:</p>
<pre>data FreeF f a = forall i. FMap (i -&gt; a) (f i)</pre>
<p>Indeed, for any type constructor <code>f</code>, <code>FreeF f</code> is a functor:</p>
<pre>instance Functor (FreeF f) where fmap g (FMap h fi) = FMap (g . h) fi</pre>
<p>As you can see, the free functor fakes the lifting of a function by recording both the function and its argument. It accumulates the lifted functions by recording their composition. Functor rules are automatically satisfied. This construction was used in a paper <a href="http://okmij.org/ftp/Haskell/extensible/more.pdf">Freer Monads, More Extensible Effects</a>.</p>
<p>Alternatively, we can use the right Kan extension for the same purpose:</p>
<pre>newtype FreeF f a = FreeF (forall i. (a -&gt; i) -&gt; f i)</pre>
<p>It&#x2019;s easy to check that this is indeed a functor:</p>
<pre>instance Functor (FreeF f) where fmap g (FreeF r) = FreeF (\bi -&gt; r (bi . g))</pre>
<p>Next: <a href="https://bartoszmilewski.com/2017/05/13/enriched-categories/">Enriched Categories</a>.</p> </div>