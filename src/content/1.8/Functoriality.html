<div class="post-content"> <br><blockquote><p>This is part 8 of Categories for Programmers. Previously: <a>Functors</a>. See the <a href="https://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/">Table of Contents</a>.</p></blockquote>
<p>Now that you know what a functor is, and have seen a few examples, let&#x2019;s see how we can build larger functors from smaller ones. In particular it&#x2019;s interesting to see which type constructors (which correspond to mappings between objects in a category) can be extended to functors (which include mappings between morphisms).</p>
<h2>Bifunctors</h2>
<p>Since functors are morphisms in <em>Cat</em> (the category of categories), a lot of intuitions about morphisms &#x2014; and functions in particular &#x2014; apply to functors as well. For instance, just like you can have a function of two arguments, you can have a functor of two arguments, or a <em>bifunctor</em>. On objects, a bifunctor maps every pair of objects, one from category C, and one from category D, to an object in category E. Notice that this is just saying that it&#x2019;s a mapping from a <em>cartesian product</em> of categories C&#xD7;D to E.</p>
<p><a href="https://bartoszmilewski.files.wordpress.com/2015/01/bifunctor.jpg"><img class="aligncenter size-medium wp-image-4068" src="https://bartoszmilewski.files.wordpress.com/2015/01/bifunctor.jpg?w=300&amp;h=286%20300w,%20https://bartoszmilewski.files.wordpress.com/2015/01/bifunctor.jpg?w=150&amp;h=143%20150w,%20https://bartoszmilewski.files.wordpress.com/2015/01/bifunctor.jpg%20313w" alt="Bifunctor" width="300" srcset="https://bartoszmilewski.files.wordpress.com/2015/01/bifunctor.jpg?w=300&amp;h=286 300w, https://bartoszmilewski.files.wordpress.com/2015/01/bifunctor.jpg?w=150&amp;h=143 150w, https://bartoszmilewski.files.wordpress.com/2015/01/bifunctor.jpg 313w"></a></p>
<p>That&#x2019;s pretty straightforward. But functoriality means that a bifunctor has to map morphisms as well. This time, though, it must map a pair of morphisms, one from C and one from D, to a morphism in E. </p>
<p>Again, a pair of morphisms is just a single morphism in the product category C&#xD7;D. We define a morphism in a cartesian product of categories as a pair of morphisms which goes from one pair of objects to another pair of objects. These pairs of morphisms can be composed in the obvious way:</p>
<pre>(f, g) &#x2218; (f&apos;, g&apos;) = (f &#x2218; f&apos;, g &#x2218; g&apos;)</pre>
<p>The composition is associative and it has an identity &#x2014; a pair of identity morphisms <em>(id, id)</em>. So a cartesian product of categories is indeed a category.</p>
<p>But an easier way to think about bifunctors is that they are functors in both arguments. So instead of translating functorial laws &#x2014; associativity and identity preservation &#x2014; from functors to bifunctors, it&#x2019;s enough to check them separately for each argument. If you have a mapping from a pair of categories to a third category, and you prove that it is functorial in each argument separately (i.e., keeping the other argument constant), then the mapping is automatically a bifunctor. By <em>functorial</em> I mean that it acts on morphisms like an honest functor.</p>
<p>Let&#x2019;s define a bifunctor in Haskell. In this case all three categories are the same: the category of Haskell types. A bifunctor is a type constructor that takes two type arguments. Here&#x2019;s the definition of the <code>Bifunctor</code> typeclass taken directly from the library <code>Control.Bifunctor</code>:</p>
<pre>class Bifunctor <span class="red">f</span> where bimap :: (a -&gt; c) -&gt; (b -&gt; d) -&gt; <span class="red">f a b</span> -&gt; <span class="red">f c d</span> bimap g h = first g . second h first :: (a -&gt; c) -&gt; <span class="red">f a b</span> -&gt; <span class="red">f c b</span> first g = bimap g id second :: (b -&gt; d) -&gt; <span class="red">f a b</span> -&gt; <span class="red">f a d</span> second = bimap id</pre>
<p>The type variable <code>f</code> represents the bifunctor. You can see that in all type signatures it&#x2019;s always applied to two type arguments. The first type signature defines <code>bimap</code>: a mapping of two functions at once. The result is a lifted function, <code>(f a b -&gt; f c d)</code>, operating on types generated by the bifunctor&#x2019;s type constructor. There is a default implementation of <code>bimap</code> in terms of <code>first</code> and <code>second</code>, which shows that it&#x2019;s enough to have functoriality in each argument separately to be able to define a bifunctor.</p>
<div id="attachment_4070" class="wp-caption aligncenter"><a href="https://bartoszmilewski.files.wordpress.com/2015/01/bimap.jpg"><img class="wp-image-4070 size-medium" src="https://bartoszmilewski.files.wordpress.com/2015/01/bimap.jpg?w=300&amp;h=292%20300w,%20https://bartoszmilewski.files.wordpress.com/2015/01/bimap.jpg?w=150&amp;h=146%20150w,%20https://bartoszmilewski.files.wordpress.com/2015/01/bimap.jpg%20438w" alt="Bimap" width="300" srcset="https://bartoszmilewski.files.wordpress.com/2015/01/bimap.jpg?w=300&amp;h=292 300w, https://bartoszmilewski.files.wordpress.com/2015/01/bimap.jpg?w=150&amp;h=146 150w, https://bartoszmilewski.files.wordpress.com/2015/01/bimap.jpg 438w"></a><p class="wp-caption-text">bimap</p></div>
<p>The two other type signatures, <code>first</code> and <code>second</code>, are the two <code>fmap</code>s witnessing the functoriality of <code>f</code> in the first and the second argument, respectively.</p>
<table width="100%">
<tbody>
<tr>
<td>
<p><div id="attachment_4071" class="wp-caption aligncenter"><a href="https://bartoszmilewski.files.wordpress.com/2015/01/first.jpg"><img class="wp-image-4071 size-thumbnail" src="https://bartoszmilewski.files.wordpress.com/2015/01/first.jpg?w=150&amp;h=124%20150w,%20https://bartoszmilewski.files.wordpress.com/2015/01/first.jpg?w=300&amp;h=248%20300w" alt="First" width="150" srcset="https://bartoszmilewski.files.wordpress.com/2015/01/first.jpg?w=150&amp;h=124 150w, https://bartoszmilewski.files.wordpress.com/2015/01/first.jpg?w=300&amp;h=248 300w"></a><p class="wp-caption-text">first</p></div></p></td>
<td>
<p><div id="attachment_4072" class="wp-caption aligncenter"><a href="https://bartoszmilewski.files.wordpress.com/2015/01/second.jpg"><img class="wp-image-4072 size-thumbnail" src="https://bartoszmilewski.files.wordpress.com/2015/01/second.jpg?w=150&amp;h=138%20150w,%20https://bartoszmilewski.files.wordpress.com/2015/01/second.jpg?w=300&amp;h=276%20300w" alt="Second" width="150" srcset="https://bartoszmilewski.files.wordpress.com/2015/01/second.jpg?w=150&amp;h=138 150w, https://bartoszmilewski.files.wordpress.com/2015/01/second.jpg?w=300&amp;h=276 300w"></a><p class="wp-caption-text">second</p></div></p></td>
</tr>
</tbody>
</table>
<p>The typeclass definition provides default implementations for both of them in terms of <code>bimap</code>. </p>
<p>When declaring an instance of <code>Bifunctor</code>, you have a choice of either implementing <code>bimap</code> and accepting the defaults for <code>first</code> and <code>second</code>, or implementing both <code>first</code> and <code>second</code> and accepting the default for <code>bimap</code> (of course, you may implement all three of them, but then it&#x2019;s up to you to make sure they are related to each other in this manner).</p>
<h2>Product and Coproduct Bifunctors</h2>
<p>An important example of a bifunctor is the categorical product &#x2014; a product of two objects that is defined by a <a href="https://bartoszmilewski.com/2015/01/07/products-and-coproducts/">universal construction</a>. If the product exists for any pair of objects, the mapping from those objects to the product is bifunctorial. This is true in general, and in Haskell in particular. Here&#x2019;s the <code>Bifunctor</code> instance for a pair constructor &#x2014; the simplest product type:</p>
<pre>instance Bifunctor (,) where bimap f g (x, y) = (f x, g y)</pre>
<p>There isn&#x2019;t much choice: <code>bimap</code> simply applies the first function to the first component, and the second function to the second component of a pair. The code pretty much writes itself, given the types:</p>
<pre>bimap :: (a -&gt; c) -&gt; (b -&gt; d) -&gt; (a, b) -&gt; (c, d)</pre>
<p>The action of the bifunctor here is to make pairs of types, for instance: </p>
<pre>(,) a b = (a, b)</pre>
<p>By duality, a coproduct, if it&#x2019;s defined for every pair of objects in a category, is also a bifunctor. In Haskell, this is exemplified by the <code>Either</code> type constructor being an instance of <code>Bifunctor</code>:</p>
<pre>instance Bifunctor Either where bimap f _ (Left x) = Left (f x) bimap _ g (Right y) = Right (g y)</pre>
<p>This code also writes itself.</p>
<p>Now, remember when we talked about monoidal categories? A monoidal category defines a binary operator acting on objects, together with a unit object. I mentioned that <code>Set</code> is a monoidal category with respect to cartesian product, with the singleton set as a unit. And it&#x2019;s also a monoidal category with respect to disjoint union, with the empty set as a unit. What I haven&#x2019;t mentioned is that one of the requirements for a monoidal category is that the binary operator be a bifunctor. This is a very important requirement &#x2014; we want the monoidal product to be compatible with the structure of the category, which is defined by morphisms. We are now one step closer to the full definition of a monoidal category (we still need to learn about naturality, before we can get there).</p>
<h2>Functorial Algebraic Data Types</h2>
<p>We&#x2019;ve seen several examples of parameterized data types that turned out to be functors &#x2014; we were able to define <code>fmap</code> for them. Complex data types are constructed from simpler data types. In particular, algebraic data types (ADTs) are created using sums and products. We have just seen that sums and products are functorial. We also know that functors compose. So if we can show that the basic building blocks of ADTs are functorial, we&#x2019;ll know that parameterized ADTs are functorial too.</p>
<p>So what are the building blocks of parameterized algebraic data types? First, there are the items that have no dependency on the type parameter of the functor, like <code>Nothing</code> in <code>Maybe</code>, or <code>Nil</code> in <code>List</code>. They are equivalent to the <code>Const</code> functor. Remember, the <code>Const</code> functor ignores its type parameter (really, the <em>second</em> type parameter, which is the one of interest to us, the first one being kept constant).</p>
<p>Then there are the elements that simply encapsulate the type parameter itself, like <code>Just</code> in <code>Maybe</code>. They are equivalent to the identity functor. I mentioned the identity functor previously, as the identity morphism in <em>Cat</em>, but didn&#x2019;t give its definition in Haskell. Here it is:</p>
<pre>data Identity a = Identity a</pre>
<pre>instance Functor Identity where fmap f (Identity x) = Identity (f x)</pre>
<p>You can think of <code>Identity</code> as the simplest possible container that always stores just one (immutable) value of type <code>a</code>.</p>
<p>Everything else in algebraic data structures is constructed from these two primitives using products and sums.</p>
<p>With this new knowledge, let&#x2019;s have a fresh look at the <code>Maybe</code> type constructor:</p>
<pre>data Maybe a = Nothing | Just a</pre>
<p>It&#x2019;s a sum of two types, and we now know that the sum is functorial. The first part, <code>Nothing</code> can be represented as a <code>Const ()</code> acting on <code>a</code> (the first type parameter of <code>Const</code> is set to unit &#x2014; later we&#x2019;ll see more interesting uses of <code>Const</code>). The second part is just a different name for the identity functor. We could have defined <code>Maybe</code>, up to isomorphism, as:</p>
<pre>type Maybe a = Either (Const () a) (Identity a)</pre>
<p>So <code>Maybe</code> is the composition of the bifunctor <code>Either</code> with two functors, <code>Const ()</code> and <code>Identity</code>. (<code>Const</code> is really a bifunctor, but here we always use it partially applied.)</p>
<p>We&#x2019;ve already seen that a composition of functors is a functor &#x2014; we can easily convince ourselves that the same is true of bifunctors. All we need is to figure out how a composition of a bifunctor with two functors works on morphisms. Given two morphisms, we simply lift one with one functor and the other with the other functor. We then lift the resulting pair of lifted morphisms with the bifunctor.</p>
<p>We can express this composition in Haskell. Let&#x2019;s define a data type that is parameterized by a bifunctor <code>bf</code> (it&#x2019;s a type variable that is a type constructor that takes two types as arguments), two functors <code>fu</code> and <code>gu</code> (type constructors that take one type variable each), and two regular types <code>a</code> and <code>b</code>. We apply <code>fu</code> to <code>a</code> and <code>gu</code> to <code>b</code>, and then apply <code>bf</code> to the resulting two types:</p>
<pre>newtype BiComp bf fu gu a b = BiComp (bf (fu a) (gu b))</pre>
<p>That&#x2019;s the composition on objects, or types. Notice how in Haskell we apply type constructors to types, just like we apply functions to arguments. The syntax is the same. </p>
<p>If you&#x2019;re getting a little lost, try applying <code>BiComp</code> to <code>Either</code>, <code>Const ()</code>, <code>Identity</code>, <code>a</code>, and <code>b</code>, in this order. You will recover our bare-bone version of <code>Maybe b</code> (<code>a</code> is ignored).</p>
<p>The new data type <code>BiComp</code> is a bifunctor in <code>a</code> and <code>b</code>, but only if <code>bf</code> is itself a <code>Bifunctor</code> and <code>fu</code> and <code>gu</code> are <code>Functor</code>s. The compiler must know that there will be a definition of <code>bimap</code> available for <code>bf</code>, and definitions of <code>fmap</code> for <code>fu</code> and <code>gu</code>. In Haskell, this is expressed as a precondition in the instance declaration: a set of class constraints followed by a double arrow:</p>
<pre>instance <span class="red">(Bifunctor bf, Functor fu, Functor gu) =&gt;</span> Bifunctor (BiComp bf fu gu) where bimap f1 f2 (BiComp x) = BiComp ((<span class="red">bimap</span> (<span class="red">fmap</span> f1) (<span class="red">fmap</span> f2)) x) </pre>
<p>The implementation of <code>bimap</code> for <code>BiComp</code> is given in terms of <code>bimap</code> for <code>bf</code> and the two <code>fmap</code>s for <code>fu</code> and <code>gu</code>. The compiler automatically infers all the types and picks the correct overloaded functions whenever <code>BiComp</code> is used. </p>
<p>The <code>x</code> in the definition of <code>bimap</code> has the type:</p>
<pre>bf (fu a) (gu b)</pre>
<p>which is quite a mouthful. The outer <code>bimap</code> breaks through the outer <code>bf</code> layer, and the two <code>fmap</code>s dig under <code>fu</code> and <code>gu</code>, respectively. If the types of <code>f1</code> and <code>f2</code> are:</p>
<pre>f1 :: a -&gt; a&apos; f2 :: b -&gt; b&apos;</pre>
<p>then the final result is of the type <code>bf (fu a&apos;) (gu b&apos;)</code>:</p>
<pre>bimap :: (fu a -&gt; fu a&apos;) -&gt; (gu b -&gt; gu b&apos;) -&gt; bf (fu a) (gu b) -&gt; bf (fu a&apos;) (gu b&apos;)</pre>
<p>If you like jigsaw puzzles, these kinds of type manipulations can provide hours of entertainment.</p>
<p>So it turns out that we didn&#x2019;t have to prove that <code>Maybe</code> was a functor &#x2014; this fact followed from the way it was constructed as a sum of two functorial primitives.</p>
<p>A perceptive reader might ask the question: If the derivation of the <code>Functor</code> instance for algebraic data types is so mechanical, can&#x2019;t it be automated and performed by the compiler? Indeed, it can, and it is. You need to enable a particular Haskell extension by including this line at the top of your source file:</p>
<pre>{-# LANGUAGE DeriveFunctor #-}</pre>
<p>and then add <code>deriving Functor</code> to your data structure:</p>
<pre>data Maybe a = Nothing | Just a deriving Functor</pre>
<p>and the corresponding <code>fmap</code> will be implemented for you.</p>
<p>The regularity of algebraic data structures makes it possible to derive instances not only of <code>Functor</code> but of several other type classes, including the <code>Eq</code> type class I mentioned before. There is also the option of teaching the compiler to derive instances of your own typeclasses, but that&#x2019;s a bit more advanced. The idea though is the same: You provide the behavior for the basic building blocks and sums and products, and let the compiler figure out the rest.</p>
<h2>Functors in C++</h2>
<p>If you are a C++ programmer, you obviously are on your own as far as implementing functors goes. However, you should be able to recognize some types of algebraic data structures in C++. If such a data structure is made into a generic template, you should be able to quickly implement <code>fmap</code> for it.</p>
<p>Let&#x2019;s have a look at a tree data structure, which we would define in Haskell as a recursive sum type:</p>
<pre>data Tree a = Leaf a | Node (Tree a) (Tree a) deriving Functor</pre>
<p>As I mentioned before, one way of implementing sum types in C++ is through class hierarchies. It would be natural, in an object-oriented language, to implement <code>fmap</code> as a virtual function of the base class <code>Functor</code> and then override it in all subclasses. Unfortunately this is impossible because <code>fmap</code> is a template, parameterized not only by the type of the object it&#x2019;s acting upon (the <code>this</code> pointer) but also by the return type of the function that&#x2019;s been applied to it. Virtual functions cannot be templatized in C++. We&#x2019;ll implement <code>fmap</code> as a generic free function, and we&#x2019;ll replace pattern matching with <code>dynamic_cast</code>.</p>
<p>The base class must define at least one virtual function in order to support dynamic casting, so we&#x2019;ll make the destructor virtual (which is a good idea in any case):</p>
<pre>template&lt;class T&gt; struct Tree { virtual ~Tree() {}; };</pre>
<p>The <code>Leaf</code> is just an <code>Identity</code> functor in disguise:</p>
<pre>template&lt;class T&gt; struct Leaf : public Tree&lt;T&gt; { T _label; Leaf(T l) : _label(l) {} };</pre>
<p>The <code>Node</code> is a product type:</p>
<pre>template&lt;class T&gt; struct Node : public Tree&lt;T&gt; { Tree&lt;T&gt; * _left; Tree&lt;T&gt; * _right; Node(Tree&lt;T&gt; * l, Tree&lt;T&gt; * r) : _left(l), _right(r) {} };</pre>
<p>When implementing <code>fmap</code> we take advantage of dynamic dispatching on the type of the <code>Tree</code>. The <code>Leaf</code> case applies the <code>Identity</code> version of <code>fmap</code>, and the <code>Node</code> case is treated like a bifunctor composed with two copies of the <code>Tree</code> functor. As a C++ programmer, you&#x2019;re probably not used to analyzing code in these terms, but it&#x2019;s a good exercise in categorical thinking.</p>
<pre>template&lt;class A, class B&gt; Tree&lt;B&gt; * fmap(std::function&lt;B(A)&gt; f, Tree&lt;A&gt; * t) { Leaf&lt;A&gt; * pl = dynamic_cast &lt;Leaf&lt;A&gt;*&gt;(t); if (pl) return new Leaf&lt;B&gt;(f (pl-&gt;_label)); Node&lt;A&gt; * pn = dynamic_cast&lt;Node&lt;A&gt;*&gt;(t); if (pn) return new Node&lt;B&gt;( fmap&lt;A&gt;(f, pn-&gt;_left) , fmap&lt;A&gt;(f, pn-&gt;_right)); return nullptr; }</pre>
<p>For simplicity, I decided to ignore memory and resource management issues, but in production code you would probably use smart pointers (unique or shared, depending on your policy).</p>
<p>Compare it with the Haskell implementation of <code>fmap</code>:</p>
<pre>instance Functor Tree where fmap f (Leaf a) = Leaf (f a) fmap f (Node t t&apos;) = Node (fmap f t) (fmap f t&apos;)</pre>
<p>This implementation can also be automatically derived by the compiler.</p>
<h2>The Writer Functor</h2>
<p>I promised that I would come back to the <a href="https://bartoszmilewski.com/2014/12/23/kleisli-categories/">Kleisli category</a> I described earlier. Morphisms in that category were represented as &#x201C;embellished&#x201D; functions returning the <code>Writer</code> data structure.</p>
<pre>type Writer a = (a, String)</pre>
<p>I said that the embellishment was somehow related to endofunctors. And, indeed, the <code>Writer</code> type constructor is functorial in <code>a</code>. We don&#x2019;t even have to implement <code>fmap</code> for it, because it&#x2019;s just a simple product type.</p>
<p>But what&#x2019;s the relation between a Kleisli category and a functor &#x2014; in general? A Kleisli category, being a category, defines composition and identity. Let&#x2019; me remind you that the composition is given by the fish operator:</p>
<pre>(&gt;=&gt;) :: (a -&gt; Writer b) -&gt; (b -&gt; Writer c) -&gt; (a -&gt; Writer c) m1 &gt;=&gt; m2 = \x -&gt; let (y, s1) = m1 x (z, s2) = m2 y in (z, s1 ++ s2)</pre>
<p>and the identity morphism by a function called <code>return</code>:</p>
<pre>return :: a -&gt; Writer a return x = (x, &quot;&quot;)</pre>
<p>It turns out that, if you look at the types of these two functions long enough (and I mean, <em>long</em> enough), you can find a way to combine them to produce a function with the right type signature to serve as <code>fmap</code>. Like this:</p>
<pre>fmap f = id &gt;=&gt; (\x -&gt; return (f x))</pre>
<p>Here, the fish operator combines two functions: one of them is the familiar <code>id</code>, and the other is a lambda that applies <code>return</code> to the result of acting with <code>f</code> on the lambda&#x2019;s argument. The hardest part to wrap your brain around is probably the use of <code>id</code>. Isn&#x2019;t the argument to the fish operator supposed to be a function that takes a &#x201C;normal&#x201D; type and returns an embellished type? Well, not really. Nobody says that <code>a</code> in <code>a -&gt; Writer b</code> must be a &#x201C;normal&#x201D; type. It&#x2019;s a type variable, so it can be anything, in particular it can be an embellished type, like <code>Writer b</code>.</p>
<p>So <code>id</code> will take <code>Writer a</code> and turn it into <code>Writer a</code>. The fish operator will fish out the value of <code>a</code> and pass it as <code>x</code> to the lambda. There, <code>f</code> will turn it into a <code>b</code> and <code>return</code> will embellish it, making it <code>Writer b</code>. Putting it all together, we end up with a function that takes <code>Writer a</code> and returns <code>Writer b</code>, exactly what <code>fmap</code> is supposed to produce.</p>
<p>Notice that this argument is very general: you can replace <code>Writer</code> with any type constructor. As long as it supports a fish operator and <code>return</code>, you can define <code>fmap</code> as well. So the embellishment in the Kleisli category is always a functor. (Not every functor, though, gives rise to a Kleisli category.)</p>
<p>You might wonder if the <code>fmap</code> we have just defined is the same <code>fmap</code> the compiler would have derived for us with <code>deriving Functor</code>. Interestingly enough, it is. This is due to the way Haskell implements polymorphic functions. It&#x2019;s called <em>parametric polymorphism</em>, and it&#x2019;s a source of so called <em>theorems for free</em>. One of those theorems says that, if there is an implementation of <code>fmap</code> for a given type constructor, one that preserves identity, then it must be unique.</p>
<h2>Covariant and Contravariant Functors</h2>
<p>Now that we&#x2019;ve reviewed the writer functor, let&#x2019;s go back to the reader functor. It was based on the partially applied function-arrow type constructor:</p>
<pre>(-&gt;) r</pre>
<p>We can rewrite it as a type synonym:</p>
<pre>type Reader r a = r -&gt; a</pre>
<p>for which the <code>Functor</code> instance, as we&#x2019;ve seen before, reads:</p>
<pre>instance Functor (Reader r) where fmap f g = f . g</pre>
<p>But just like the pair type constructor, or the <code>Either</code> type constructor, the function type constructor takes two type arguments. The pair and <code>Either</code> were functorial in both arguments &#x2014; they were bifunctors. Is the function constructor a bifunctor too?</p>
<p>Let&#x2019;s try to make it functorial in the first argument. We&#x2019;ll start with a type synonym &#x2014; it&#x2019;s just like the <code>Reader</code> but with the arguments flipped:</p>
<pre>type Op r a = a -&gt; r</pre>
<p>This time we fix the return type, <code>r</code>, and vary the argument type, <code>a</code>. Let&#x2019;s see if we can somehow match the types in order to implement <code>fmap</code>, which would have the following type signature:</p>
<pre>fmap :: (a -&gt; b) -&gt; (a -&gt; r) -&gt; (b -&gt; r)</pre>
<p>With just two functions taking <code>a</code> and returning, respectively, <code>b</code> and <code>r</code>, there is simply no way to build a function taking <code>b</code> and returning <code>r</code>! It would be different if we could somehow invert the first function, so that it took <code>b</code> and returned <code>a</code> instead. We can&#x2019;t invert an arbitrary function, but we can go to the opposite category.</p>
<p>A short recap: For every category <em>C</em> there is a dual category <em>C<sup>op</sup></em>. It&#x2019;s a category with the same objects as <em>C</em>, but with all the arrows reversed. </p>
<p>Consider a functor that goes between <em>C<sup>op</sup></em> and some other category <em>D</em>:<br>
<em>F :: C<sup>op</sup> &#x2192; D</em><br>
Such a functor maps a morphism <em>f<sup>op</sup> :: a &#x2192; b</em> in <em>C<sup>op</sup></em> to the morphism <em>F f<sup>op</sup> :: F a &#x2192; F b</em> in <em>D</em>. But the morphism <em>f<sup>op</sup></em> secretly corresponds to some morphism <em>f :: b &#x2192; a</em> in the original category <em>C</em>. Notice the inversion.</p>
<p>Now, <em>F</em> is a regular functor, but there is another mapping we can define based on <em>F</em>, which is not a functor &#x2014; let&#x2019;s call it <em>G</em>. It&#x2019;s a mapping from <em>C</em> to <em>D</em>. It maps objects the same way <em>F</em> does, but when it comes to mapping morphisms, it reverses them. It takes a morphism <em>f :: b &#x2192; a</em> in <em>C</em>, maps it first to the opposite morphism <em>f<sup>op</sup> :: a &#x2192; b</em> and then uses the functor F on it, to get <em>F f<sup>op</sup> :: F a &#x2192; F b</em>.</p>
<p><a href="https://bartoszmilewski.files.wordpress.com/2015/01/contravariant.jpg"><img class="aligncenter size-medium wp-image-4077" src="https://bartoszmilewski.files.wordpress.com/2015/01/contravariant.jpg?w=300&amp;h=295%20300w,%20https://bartoszmilewski.files.wordpress.com/2015/01/contravariant.jpg?w=150&amp;h=148%20150w,%20https://bartoszmilewski.files.wordpress.com/2015/01/contravariant.jpg%20530w" alt="Contravariant" width="300" srcset="https://bartoszmilewski.files.wordpress.com/2015/01/contravariant.jpg?w=300&amp;h=295 300w, https://bartoszmilewski.files.wordpress.com/2015/01/contravariant.jpg?w=150&amp;h=148 150w, https://bartoszmilewski.files.wordpress.com/2015/01/contravariant.jpg 530w"></a></p>
<p>Considering that <em>F a</em> is the same as <em>G a</em> and <em>F b</em> is the same as <em>G b</em>, the whole trip can be described as:<br>
<em>G f :: (b &#x2192; a) &#x2192; (G a &#x2192; G b)</em><br>
It&#x2019;s a &#x201C;functor with a twist.&#x201D; A mapping of categories that inverts the direction of morphisms in this manner is called a <em>contravariant functor</em>. Notice that a contravariant functor is just a regular functor from the opposite category. The regular functors, by the way &#x2014; the kind we&#x2019;ve been studying thus far &#x2014; are called <em>covariant</em> functors.</p>
<p>Here&#x2019;s the typeclass defining a contravariant functor (really, a contravariant <em>endo</em>functor) in Haskell:</p>
<pre>class Contravariant f where contramap :: (b -&gt; a) -&gt; (f a -&gt; f b)</pre>
<p>Our type constructor <code>Op</code> is an instance of it:</p>
<pre>instance Contravariant (Op r) where -- (b -&gt; a) -&gt; Op r a -&gt; Op r b contramap f g = g . f</pre>
<p>Notice that the function <code>f</code> inserts itself <em>before</em> (that is, to the right of) the contents of <code>Op</code> &#x2014; the function <code>g</code>.</p>
<p>The definition of <code>contramap</code> for <code>Op</code> may be made even terser, if you notice that it&#x2019;s just the function composition operator with the arguments flipped. There is a special function for flipping arguments, called <code>flip</code>:</p>
<pre>flip :: (a -&gt; b -&gt; c) -&gt; (b -&gt; a -&gt; c) flip f y x = f x y</pre>
<p>With it, we get:</p>
<pre>contramap = flip (.)</pre>
<h2>Profunctors</h2>
<p>We&#x2019;ve seen that the function-arrow operator is contravariant in its first argument and covariant in the second. Is there a name for such a beast? It turns out that, if the target category is <strong>Set</strong>, such a beast is called a <em>profunctor</em>. Because a contravariant functor is equivalent to a covariant functor from the opposite category, a profunctor is defined as:<br>
<i>C<sup>op</sup> &#xD7; D &#x2192; Set</i></p>
<p>Since, to first approximation, Haskell types are sets, we apply the name <code>Profunctor</code> to a type constructor <code>p</code> of two arguments, which is contra-functorial in the first argument and functorial in the second. Here&#x2019;s the appropriate typeclass taken from the <code>Data.Profunctor</code> library:</p>
<pre>class Profunctor p where dimap :: (a -&gt; b) -&gt; (c -&gt; d) -&gt; p b c -&gt; p a d dimap f g = lmap f . rmap g lmap :: (a -&gt; b) -&gt; p b c -&gt; p a c lmap f = dimap f id rmap :: (b -&gt; c) -&gt; p a b -&gt; p a c rmap = dimap id</pre>
<p>All three functions come with default implementations. Just like with <code>Bifunctor</code>, when declaring an instance of <code>Profunctor</code>, you have a choice of either implementing <code>dimap</code> and accepting the defaults for <code>lmap</code> and <code>rmap</code>, or implementing both <code>lmap</code> and <code>rmap</code> and accepting the default for <code>dimap</code>.</p>
<div id="attachment_4078" class="wp-caption aligncenter"><a href="https://bartoszmilewski.files.wordpress.com/2015/01/dimap.jpg"><img class="size-medium wp-image-4078" src="https://bartoszmilewski.files.wordpress.com/2015/01/dimap.jpg?w=300&amp;h=243%20300w,%20https://bartoszmilewski.files.wordpress.com/2015/01/dimap.jpg?w=150&amp;h=122%20150w,%20https://bartoszmilewski.files.wordpress.com/2015/01/dimap.jpg%20497w" alt="dimap" width="300" srcset="https://bartoszmilewski.files.wordpress.com/2015/01/dimap.jpg?w=300&amp;h=243 300w, https://bartoszmilewski.files.wordpress.com/2015/01/dimap.jpg?w=150&amp;h=122 150w, https://bartoszmilewski.files.wordpress.com/2015/01/dimap.jpg 497w"></a><p class="wp-caption-text">dimap</p></div>
<p>Now we can assert that the function-arrow operator is an instance of a <code>Profunctor</code>:</p>
<pre>instance Profunctor (-&gt;) where dimap ab cd bc = cd . bc . ab lmap = flip (.) rmap = (.)</pre>
<p>Profunctors have their application in the Haskell lens library. We&#x2019;ll see them again when we talk about ends and coends.</p>
<h2>Challenges</h2>
<ol>
<li>Show that the data type:
<pre>data Pair a b = Pair a b</pre>
<p>is a bifunctor. For additional credit implement all three methods of <code>Bifunctor</code> and use equational reasoning to show that these definitions are compatible with the default implementations whenever they can be applied.</p></li>
<li>Show the isomorphism between the standard definition of <code>Maybe</code> and this desugaring:
<pre>type Maybe&apos; a = Either (Const () a) (Identity a)</pre>
<p>Hint: Define two mappings between the two implementations. For additional credit, show that they are the inverse of each other using equational reasoning.</p></li>
<li>Let&#x2019;s try another data structure. I call it a <code>PreList</code> because it&#x2019;s a precursor to a <code>List</code>. It replaces recursion with a type parameter <code>b</code>.
<pre>data PreList a b = Nil | Cons a b</pre>
<p>You could recover our earlier definition of a <code>List</code> by recursively applying <code>PreList</code> to itself (we&#x2019;ll see how it&#x2019;s done when we talk about fixed points).</p>
<p>Show that <code>PreList</code> is an instance of <code>Bifunctor</code>.</p></li>
<li>Show that the following data types define bifunctors in <code>a</code> and <code>b</code>:
<pre>data K2 c a b = K2 c</pre>
<pre>data Fst a b = Fst a</pre>
<pre>data Snd a b = Snd b</pre>
<p>For additional credit, check your solutions agains Conor McBride&#x2019;s paper <a href="http://strictlypositive.org/CJ.pdf">Clowns to the Left of me, Jokers to the Right</a>.</p></li>
<li>Define a bifunctor in a language other than Haskell. Implement <code>bimap</code> for a generic pair in that language.</li>
<li>Should <code>std::map</code> be considered a bifunctor or a profunctor in the two template arguments <code>Key</code> and <code>T</code>? How would you redesign this data type to make it so?</li>
</ol>
<p>Next: <a href="https://bartoszmilewski.com/2015/03/13/function-types/">Function Types</a>.</p>
<h2>Acknowledgment</h2>
<p>As usual, big thanks go to Gershom Bazerman for reviewing this article.<br>
<a href="https://twitter.com/BartoszMilewski" class="twitter-follow-button">Follow @BartoszMilewski</a></p> </div>