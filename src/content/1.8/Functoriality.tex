\begin{quote}
This is part 8 of Categories for Programmers. Previously: {Functors}.
See the
\href{https://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/}{Table
of Contents}.
\end{quote}

Now that you know what a functor is, and have seen a few examples, let's
see how we can build larger functors from smaller ones. In particular
it's interesting to see which type constructors (which correspond to
mappings between objects in a category) can be extended to functors
(which include mappings between morphisms).

\subsection{Bifunctors}\label{bifunctors}

Since functors are morphisms in \emph{Cat} (the category of categories),
a lot of intuitions about morphisms --- and functions in particular ---
apply to functors as well. For instance, just like you can have a
function of two arguments, you can have a functor of two arguments, or a
\emph{bifunctor}. On objects, a bifunctor maps every pair of objects,
one from category C, and one from category D, to an object in category
E. Notice that this is just saying that it's a mapping from a
\emph{cartesian product} of categories C×D to E.

\includegraphics[width=3.12500in]{images/bifunctor.jpg}

That's pretty straightforward. But functoriality means that a bifunctor
has to map morphisms as well. This time, though, it must map a pair of
morphisms, one from C and one from D, to a morphism in E.

Again, a pair of morphisms is just a single morphism in the product
category C×D. We define a morphism in a cartesian product of categories
as a pair of morphisms which goes from one pair of objects to another
pair of objects. These pairs of morphisms can be composed in the obvious
way:

\begin{verbatim}
(f, g) ∘ (f&apos;, g&apos;) = (f ∘ f&apos;, g ∘ g&apos;)
\end{verbatim}

The composition is associative and it has an identity --- a pair of
identity morphisms \emph{(id, id)}. So a cartesian product of categories
is indeed a category.

But an easier way to think about bifunctors is that they are functors in
both arguments. So instead of translating functorial laws ---
associativity and identity preservation --- from functors to bifunctors,
it's enough to check them separately for each argument. If you have a
mapping from a pair of categories to a third category, and you prove
that it is functorial in each argument separately (i.e., keeping the
other argument constant), then the mapping is automatically a bifunctor.
By \emph{functorial} I mean that it acts on morphisms like an honest
functor.

Let's define a bifunctor in Haskell. In this case all three categories
are the same: the category of Haskell types. A bifunctor is a type
constructor that takes two type arguments. Here's the definition of the
\texttt{Bifunctor} typeclass taken directly from the library
\texttt{Control.Bifunctor}:

\begin{verbatim}
class Bifunctor f where bimap :: (a -> c) -> (b -> d) -> f a b -> f c d bimap g h = first g . second h first :: (a -> c) -> f a b -> f c b first g = bimap g id second :: (b -> d) -> f a b -> f a d second = bimap id
\end{verbatim}

The type variable \texttt{f} represents the bifunctor. You can see that
in all type signatures it's always applied to two type arguments. The
first type signature defines \texttt{bimap}: a mapping of two functions
at once. The result is a lifted function,
\texttt{(f\ a\ b\ -\textgreater{}\ f\ c\ d)}, operating on types
generated by the bifunctor's type constructor. There is a default
implementation of \texttt{bimap} in terms of \texttt{first} and
\texttt{second}, which shows that it's enough to have functoriality in
each argument separately to be able to define a bifunctor.

\hypertarget{attachment_4070}{}
\includegraphics[width=3.12500in]{images/bimap.jpg}

bimap

The two other type signatures, \texttt{first} and \texttt{second}, are
the two \texttt{fmap}s witnessing the functoriality of \texttt{f} in the
first and the second argument, respectively.

\begin{longtable}[]{@{}ll@{}}
\toprule
\begin{minipage}[t]{0.48\columnwidth}\raggedright\strut
\hypertarget{attachment_4071}{}
\includegraphics[width=1.56250in]{images/first.jpg}

first\strut
\end{minipage} & \begin{minipage}[t]{0.48\columnwidth}\raggedright\strut
\hypertarget{attachment_4072}{}
\includegraphics[width=1.56250in]{images/second.jpg}

second\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

The typeclass definition provides default implementations for both of
them in terms of \texttt{bimap}.

When declaring an instance of \texttt{Bifunctor}, you have a choice of
either implementing \texttt{bimap} and accepting the defaults for
\texttt{first} and \texttt{second}, or implementing both \texttt{first}
and \texttt{second} and accepting the default for \texttt{bimap} (of
course, you may implement all three of them, but then it's up to you to
make sure they are related to each other in this manner).

\subsection{Product and Coproduct
Bifunctors}\label{product-and-coproduct-bifunctors}

An important example of a bifunctor is the categorical product --- a
product of two objects that is defined by a
\href{https://bartoszmilewski.com/2015/01/07/products-and-coproducts/}{universal
construction}. If the product exists for any pair of objects, the
mapping from those objects to the product is bifunctorial. This is true
in general, and in Haskell in particular. Here's the \texttt{Bifunctor}
instance for a pair constructor --- the simplest product type:

\begin{verbatim}
instance Bifunctor (,) where bimap f g (x, y) = (f x, g y)
\end{verbatim}

There isn't much choice: \texttt{bimap} simply applies the first
function to the first component, and the second function to the second
component of a pair. The code pretty much writes itself, given the
types:

\begin{verbatim}
bimap :: (a -> c) -> (b -> d) -> (a, b) -> (c, d)
\end{verbatim}

The action of the bifunctor here is to make pairs of types, for
instance:

\begin{verbatim}
(,) a b = (a, b)
\end{verbatim}

By duality, a coproduct, if it's defined for every pair of objects in a
category, is also a bifunctor. In Haskell, this is exemplified by the
\texttt{Either} type constructor being an instance of
\texttt{Bifunctor}:

\begin{verbatim}
instance Bifunctor Either where bimap f _ (Left x) = Left (f x) bimap _ g (Right y) = Right (g y)
\end{verbatim}

This code also writes itself.

Now, remember when we talked about monoidal categories? A monoidal
category defines a binary operator acting on objects, together with a
unit object. I mentioned that \texttt{Set} is a monoidal category with
respect to cartesian product, with the singleton set as a unit. And it's
also a monoidal category with respect to disjoint union, with the empty
set as a unit. What I haven't mentioned is that one of the requirements
for a monoidal category is that the binary operator be a bifunctor. This
is a very important requirement --- we want the monoidal product to be
compatible with the structure of the category, which is defined by
morphisms. We are now one step closer to the full definition of a
monoidal category (we still need to learn about naturality, before we
can get there).

\subsection{Functorial Algebraic Data
Types}\label{functorial-algebraic-data-types}

We've seen several examples of parameterized data types that turned out
to be functors --- we were able to define \texttt{fmap} for them.
Complex data types are constructed from simpler data types. In
particular, algebraic data types (ADTs) are created using sums and
products. We have just seen that sums and products are functorial. We
also know that functors compose. So if we can show that the basic
building blocks of ADTs are functorial, we'll know that parameterized
ADTs are functorial too.

So what are the building blocks of parameterized algebraic data types?
First, there are the items that have no dependency on the type parameter
of the functor, like \texttt{Nothing} in \texttt{Maybe}, or \texttt{Nil}
in \texttt{List}. They are equivalent to the \texttt{Const} functor.
Remember, the \texttt{Const} functor ignores its type parameter (really,
the \emph{second} type parameter, which is the one of interest to us,
the first one being kept constant).

Then there are the elements that simply encapsulate the type parameter
itself, like \texttt{Just} in \texttt{Maybe}. They are equivalent to the
identity functor. I mentioned the identity functor previously, as the
identity morphism in \emph{Cat}, but didn't give its definition in
Haskell. Here it is:

\begin{verbatim}
data Identity a = Identity a
\end{verbatim}

\begin{verbatim}
instance Functor Identity where fmap f (Identity x) = Identity (f x)
\end{verbatim}

You can think of \texttt{Identity} as the simplest possible container
that always stores just one (immutable) value of type \texttt{a}.

Everything else in algebraic data structures is constructed from these
two primitives using products and sums.

With this new knowledge, let's have a fresh look at the \texttt{Maybe}
type constructor:

\begin{verbatim}
data Maybe a = Nothing | Just a
\end{verbatim}

It's a sum of two types, and we now know that the sum is functorial. The
first part, \texttt{Nothing} can be represented as a \texttt{Const\ ()}
acting on \texttt{a} (the first type parameter of \texttt{Const} is set
to unit --- later we'll see more interesting uses of \texttt{Const}).
The second part is just a different name for the identity functor. We
could have defined \texttt{Maybe}, up to isomorphism, as:

\begin{verbatim}
type Maybe a = Either (Const () a) (Identity a)
\end{verbatim}

So \texttt{Maybe} is the composition of the bifunctor \texttt{Either}
with two functors, \texttt{Const\ ()} and \texttt{Identity}.
(\texttt{Const} is really a bifunctor, but here we always use it
partially applied.)

We've already seen that a composition of functors is a functor --- we
can easily convince ourselves that the same is true of bifunctors. All
we need is to figure out how a composition of a bifunctor with two
functors works on morphisms. Given two morphisms, we simply lift one
with one functor and the other with the other functor. We then lift the
resulting pair of lifted morphisms with the bifunctor.

We can express this composition in Haskell. Let's define a data type
that is parameterized by a bifunctor \texttt{bf} (it's a type variable
that is a type constructor that takes two types as arguments), two
functors \texttt{fu} and \texttt{gu} (type constructors that take one
type variable each), and two regular types \texttt{a} and \texttt{b}. We
apply \texttt{fu} to \texttt{a} and \texttt{gu} to \texttt{b}, and then
apply \texttt{bf} to the resulting two types:

\begin{verbatim}
newtype BiComp bf fu gu a b = BiComp (bf (fu a) (gu b))
\end{verbatim}

That's the composition on objects, or types. Notice how in Haskell we
apply type constructors to types, just like we apply functions to
arguments. The syntax is the same.

If you're getting a little lost, try applying \texttt{BiComp} to
\texttt{Either}, \texttt{Const\ ()}, \texttt{Identity}, \texttt{a}, and
\texttt{b}, in this order. You will recover our bare-bone version of
\texttt{Maybe\ b} (\texttt{a} is ignored).

The new data type \texttt{BiComp} is a bifunctor in \texttt{a} and
\texttt{b}, but only if \texttt{bf} is itself a \texttt{Bifunctor} and
\texttt{fu} and \texttt{gu} are \texttt{Functor}s. The compiler must
know that there will be a definition of \texttt{bimap} available for
\texttt{bf}, and definitions of \texttt{fmap} for \texttt{fu} and
\texttt{gu}. In Haskell, this is expressed as a precondition in the
instance declaration: a set of class constraints followed by a double
arrow:

\begin{verbatim}
instance (Bifunctor bf, Functor fu, Functor gu) => Bifunctor (BiComp bf fu gu) where bimap f1 f2 (BiComp x) = BiComp ((bimap (fmap f1) (fmap f2)) x) 
\end{verbatim}

The implementation of \texttt{bimap} for \texttt{BiComp} is given in
terms of \texttt{bimap} for \texttt{bf} and the two \texttt{fmap}s for
\texttt{fu} and \texttt{gu}. The compiler automatically infers all the
types and picks the correct overloaded functions whenever
\texttt{BiComp} is used.

The \texttt{x} in the definition of \texttt{bimap} has the type:

\begin{verbatim}
bf (fu a) (gu b)
\end{verbatim}

which is quite a mouthful. The outer \texttt{bimap} breaks through the
outer \texttt{bf} layer, and the two \texttt{fmap}s dig under
\texttt{fu} and \texttt{gu}, respectively. If the types of \texttt{f1}
and \texttt{f2} are:

\begin{verbatim}
f1 :: a -> a&apos; f2 :: b -> b&apos;
\end{verbatim}

then the final result is of the type
\texttt{bf\ (fu\ a\&apos;)\ (gu\ b\&apos;)}:

\begin{verbatim}
bimap (fu a -> fu a&apos;) -> (gu b -> gu b&apos;) -> bf (fu a) (gu b) -> bf (fu a&apos;) (gu b&apos;)
\end{verbatim}

If you like jigsaw puzzles, these kinds of type manipulations can
provide hours of entertainment.

So it turns out that we didn't have to prove that \texttt{Maybe} was a
functor --- this fact followed from the way it was constructed as a sum
of two functorial primitives.

A perceptive reader might ask the question: If the derivation of the
\texttt{Functor} instance for algebraic data types is so mechanical,
can't it be automated and performed by the compiler? Indeed, it can, and
it is. You need to enable a particular Haskell extension by including
this line at the top of your source file:

\begin{verbatim}
{-# LANGUAGE DeriveFunctor #-}
\end{verbatim}

and then add \texttt{deriving\ Functor} to your data structure:

\begin{verbatim}
data Maybe a = Nothing | Just a deriving Functor
\end{verbatim}

and the corresponding \texttt{fmap} will be implemented for you.

The regularity of algebraic data structures makes it possible to derive
instances not only of \texttt{Functor} but of several other type
classes, including the \texttt{Eq} type class I mentioned before. There
is also the option of teaching the compiler to derive instances of your
own typeclasses, but that's a bit more advanced. The idea though is the
same: You provide the behavior for the basic building blocks and sums
and products, and let the compiler figure out the rest.

\subsection{Functors in C++}\label{functors-in-c}

If you are a C++ programmer, you obviously are on your own as far as
implementing functors goes. However, you should be able to recognize
some types of algebraic data structures in C++. If such a data structure
is made into a generic template, you should be able to quickly implement
\texttt{fmap} for it.

Let's have a look at a tree data structure, which we would define in
Haskell as a recursive sum type:

\begin{verbatim}
data Tree a = Leaf a | Node (Tree a) (Tree a) deriving Functor
\end{verbatim}

As I mentioned before, one way of implementing sum types in C++ is
through class hierarchies. It would be natural, in an object-oriented
language, to implement \texttt{fmap} as a virtual function of the base
class \texttt{Functor} and then override it in all subclasses.
Unfortunately this is impossible because \texttt{fmap} is a template,
parameterized not only by the type of the object it's acting upon (the
\texttt{this} pointer) but also by the return type of the function
that's been applied to it. Virtual functions cannot be templatized in
C++. We'll implement \texttt{fmap} as a generic free function, and we'll
replace pattern matching with \texttt{dynamic\_cast}.

The base class must define at least one virtual function in order to
support dynamic casting, so we'll make the destructor virtual (which is
a good idea in any case):

\begin{verbatim}
template<class T> struct Tree { virtual ~Tree() {}; };
\end{verbatim}

The \texttt{Leaf} is just an \texttt{Identity} functor in disguise:

\begin{verbatim}
template<class T> struct Leaf : public Tree<T> { T _label; Leaf(T l) : _label(l) {} };
\end{verbatim}

The \texttt{Node} is a product type:

\begin{verbatim}
template<class T> struct Node : public Tree<T> { Tree<T> * _left; Tree<T> * _right; Node(Tree<T> * l, Tree<T> * r) : _left(l), _right(r) {} };
\end{verbatim}

When implementing \texttt{fmap} we take advantage of dynamic dispatching
on the type of the \texttt{Tree}. The \texttt{Leaf} case applies the
\texttt{Identity} version of \texttt{fmap}, and the \texttt{Node} case
is treated like a bifunctor composed with two copies of the
\texttt{Tree} functor. As a C++ programmer, you're probably not used to
analyzing code in these terms, but it's a good exercise in categorical
thinking.

\begin{verbatim}
template<class A, class B> Tree<B> * fmap(std::function<B(A)> f, Tree<A> * t) { Leaf<A> * pl = dynamic_cast <Leaf<A>*>(t); if (pl) return new Leaf<B>(f (pl->_label)); Node<A> * pn = dynamic_cast<Node<A>*>(t); if (pn) return new Node<B>( fmap<A>(f, pn->_left) , fmap<A>(f, pn->_right)); return nullptr; }
\end{verbatim}

For simplicity, I decided to ignore memory and resource management
issues, but in production code you would probably use smart pointers
(unique or shared, depending on your policy).

Compare it with the Haskell implementation of \texttt{fmap}:

\begin{verbatim}
instance Functor Tree where fmap f (Leaf a) = Leaf (f a) fmap f (Node t t&apos;) = Node (fmap f t) (fmap f t&apos;)
\end{verbatim}

This implementation can also be automatically derived by the compiler.

\subsection{The Writer Functor}\label{the-writer-functor}

I promised that I would come back to the
\href{https://bartoszmilewski.com/2014/12/23/kleisli-categories/}{Kleisli
category} I described earlier. Morphisms in that category were
represented as ``embellished'' functions returning the \texttt{Writer}
data structure.

\begin{verbatim}
type Writer a = (a, String)
\end{verbatim}

I said that the embellishment was somehow related to endofunctors. And,
indeed, the \texttt{Writer} type constructor is functorial in
\texttt{a}. We don't even have to implement \texttt{fmap} for it,
because it's just a simple product type.

But what's the relation between a Kleisli category and a functor --- in
general? A Kleisli category, being a category, defines composition and
identity. Let' me remind you that the composition is given by the fish
operator:

\begin{verbatim}
(>=>) :: (a -> Writer b) -> (b -> Writer c) -> (a -> Writer c) m1 >=> m2 = \x -> let (y, s1) = m1 x (z, s2) = m2 y in (z, s1 ++ s2)
\end{verbatim}

and the identity morphism by a function called \texttt{return}:

\begin{verbatim}
return :: a -> Writer a return x = (x, "")
\end{verbatim}

It turns out that, if you look at the types of these two functions long
enough (and I mean, \emph{long} enough), you can find a way to combine
them to produce a function with the right type signature to serve as
\texttt{fmap}. Like this:

\begin{verbatim}
fmap f = id >=> (\x -> return (f x))
\end{verbatim}

Here, the fish operator combines two functions: one of them is the
familiar \texttt{id}, and the other is a lambda that applies
\texttt{return} to the result of acting with \texttt{f} on the lambda's
argument. The hardest part to wrap your brain around is probably the use
of \texttt{id}. Isn't the argument to the fish operator supposed to be a
function that takes a ``normal'' type and returns an embellished type?
Well, not really. Nobody says that \texttt{a} in
\texttt{a\ -\textgreater{}\ Writer\ b} must be a ``normal'' type. It's a
type variable, so it can be anything, in particular it can be an
embellished type, like \texttt{Writer\ b}.

So \texttt{id} will take \texttt{Writer\ a} and turn it into
\texttt{Writer\ a}. The fish operator will fish out the value of
\texttt{a} and pass it as \texttt{x} to the lambda. There, \texttt{f}
will turn it into a \texttt{b} and \texttt{return} will embellish it,
making it \texttt{Writer\ b}. Putting it all together, we end up with a
function that takes \texttt{Writer\ a} and returns \texttt{Writer\ b},
exactly what \texttt{fmap} is supposed to produce.

Notice that this argument is very general: you can replace
\texttt{Writer} with any type constructor. As long as it supports a fish
operator and \texttt{return}, you can define \texttt{fmap} as well. So
the embellishment in the Kleisli category is always a functor. (Not
every functor, though, gives rise to a Kleisli category.)

You might wonder if the \texttt{fmap} we have just defined is the same
\texttt{fmap} the compiler would have derived for us with
\texttt{deriving\ Functor}. Interestingly enough, it is. This is due to
the way Haskell implements polymorphic functions. It's called
\emph{parametric polymorphism}, and it's a source of so called
\emph{theorems for free}. One of those theorems says that, if there is
an implementation of \texttt{fmap} for a given type constructor, one
that preserves identity, then it must be unique.

\subsection{Covariant and Contravariant
Functors}\label{covariant-and-contravariant-functors}

Now that we've reviewed the writer functor, let's go back to the reader
functor. It was based on the partially applied function-arrow type
constructor:

\begin{verbatim}
(->) r
\end{verbatim}

We can rewrite it as a type synonym:

\begin{verbatim}
type Reader r a = r -> a
\end{verbatim}

for which the \texttt{Functor} instance, as we've seen before, reads:

\begin{verbatim}
instance Functor (Reader r) where fmap f g = f . g
\end{verbatim}

But just like the pair type constructor, or the \texttt{Either} type
constructor, the function type constructor takes two type arguments. The
pair and \texttt{Either} were functorial in both arguments --- they were
bifunctors. Is the function constructor a bifunctor too?

Let's try to make it functorial in the first argument. We'll start with
a type synonym --- it's just like the \texttt{Reader} but with the
arguments flipped:

\begin{verbatim}
type Op r a = a -> r
\end{verbatim}

This time we fix the return type, \texttt{r}, and vary the argument
type, \texttt{a}. Let's see if we can somehow match the types in order
to implement \texttt{fmap}, which would have the following type
signature:

\begin{verbatim}
fmap :: (a -> b) -> (a -> r) -> (b -> r)
\end{verbatim}

With just two functions taking \texttt{a} and returning, respectively,
\texttt{b} and \texttt{r}, there is simply no way to build a function
taking \texttt{b} and returning \texttt{r}! It would be different if we
could somehow invert the first function, so that it took \texttt{b} and
returned \texttt{a} instead. We can't invert an arbitrary function, but
we can go to the opposite category.

A short recap: For every category \emph{C} there is a dual category
\emph{C\textsuperscript{op}}. It's a category with the same objects as
\emph{C}, but with all the arrows reversed.

Consider a functor that goes between \emph{C\textsuperscript{op}} and
some other category \emph{D}:\\
\emph{F :: C\textsuperscript{op} → D}\\
Such a functor maps a morphism \emph{f\textsuperscript{op} :: a → b} in
\emph{C\textsuperscript{op}} to the morphism \emph{F
f\textsuperscript{op} :: F a → F b} in \emph{D}. But the morphism
\emph{f\textsuperscript{op}} secretly corresponds to some morphism
\emph{f :: b → a} in the original category \emph{C}. Notice the
inversion.

Now, \emph{F} is a regular functor, but there is another mapping we can
define based on \emph{F}, which is not a functor --- let's call it
\emph{G}. It's a mapping from \emph{C} to \emph{D}. It maps objects the
same way \emph{F} does, but when it comes to mapping morphisms, it
reverses them. It takes a morphism \emph{f :: b → a} in \emph{C}, maps
it first to the opposite morphism \emph{f\textsuperscript{op} :: a → b}
and then uses the functor F on it, to get \emph{F f\textsuperscript{op}
:: F a → F b}.

\includegraphics[width=3.12500in]{images/contravariant.jpg}

Considering that \emph{F a} is the same as \emph{G a} and \emph{F b} is
the same as \emph{G b}, the whole trip can be described as:\\
\emph{G f :: (b → a) → (G a → G b)}\\
It's a ``functor with a twist.'' A mapping of categories that inverts
the direction of morphisms in this manner is called a
\emph{contravariant functor}. Notice that a contravariant functor is
just a regular functor from the opposite category. The regular functors,
by the way --- the kind we've been studying thus far --- are called
\emph{covariant} functors.

Here's the typeclass defining a contravariant functor (really, a
contravariant \emph{endo}functor) in Haskell:

\begin{verbatim}
class Contravariant f where contramap :: (b -> a) -> (f a -> f b)
\end{verbatim}

Our type constructor \texttt{Op} is an instance of it:

\begin{verbatim}
instance Contravariant (Op r) where -- (b -> a) -> Op r a -> Op r b contramap f g = g . f
\end{verbatim}

Notice that the function \texttt{f} inserts itself \emph{before} (that
is, to the right of) the contents of \texttt{Op} --- the function
\texttt{g}.

The definition of \texttt{contramap} for \texttt{Op} may be made even
terser, if you notice that it's just the function composition operator
with the arguments flipped. There is a special function for flipping
arguments, called \texttt{flip}:

\begin{verbatim}
flip :: (a -> b -> c) -> (b -> a -> c) flip f y x = f x y
\end{verbatim}

With it, we get:

\begin{verbatim}
contramap = flip (.)
\end{verbatim}

\subsection{Profunctors}\label{profunctors}

We've seen that the function-arrow operator is contravariant in its
first argument and covariant in the second. Is there a name for such a
beast? It turns out that, if the target category is \textbf{Set}, such a
beast is called a \emph{profunctor}. Because a contravariant functor is
equivalent to a covariant functor from the opposite category, a
profunctor is defined as:\\
\emph{C\textsuperscript{op} × D → Set}

Since, to first approximation, Haskell types are sets, we apply the name
\texttt{Profunctor} to a type constructor \texttt{p} of two arguments,
which is contra-functorial in the first argument and functorial in the
second. Here's the appropriate typeclass taken from the
\texttt{Data.Profunctor} library:

\begin{verbatim}
class Profunctor p where dimap :: (a -> b) -> (c -> d) -> p b c -> p a d dimap f g = lmap f . rmap g lmap :: (a -> b) -> p b c -> p a c lmap f = dimap f id rmap :: (b -> c) -> p a b -> p a c rmap = dimap id
\end{verbatim}

All three functions come with default implementations. Just like with
\texttt{Bifunctor}, when declaring an instance of \texttt{Profunctor},
you have a choice of either implementing \texttt{dimap} and accepting
the defaults for \texttt{lmap} and \texttt{rmap}, or implementing both
\texttt{lmap} and \texttt{rmap} and accepting the default for
\texttt{dimap}.

\hypertarget{attachment_4078}{}
\includegraphics[width=3.12500in]{images/dimap.jpg}

dimap

Now we can assert that the function-arrow operator is an instance of a
\texttt{Profunctor}:

\begin{verbatim}
instance Profunctor (->) where dimap ab cd bc = cd . bc . ab lmap = flip (.) rmap = (.)
\end{verbatim}

Profunctors have their application in the Haskell lens library. We'll
see them again when we talk about ends and coends.

\subsection{Challenges}\label{challenges}

\begin{enumerate}
\item
  Show that the data type:

\begin{verbatim}
data Pair a b = Pair a b
\end{verbatim}

  is a bifunctor. For additional credit implement all three methods of
  \texttt{Bifunctor} and use equational reasoning to show that these
  definitions are compatible with the default implementations whenever
  they can be applied.
\item
  Show the isomorphism between the standard definition of \texttt{Maybe}
  and this desugaring:

\begin{verbatim}
type Maybe&apos; a = Either (Const () a) (Identity a)
\end{verbatim}

  Hint: Define two mappings between the two implementations. For
  additional credit, show that they are the inverse of each other using
  equational reasoning.
\item
  Let's try another data structure. I call it a \texttt{PreList} because
  it's a precursor to a \texttt{List}. It replaces recursion with a type
  parameter \texttt{b}.

\begin{verbatim}
data PreList a b = Nil | Cons a b
\end{verbatim}

  You could recover our earlier definition of a \texttt{List} by
  recursively applying \texttt{PreList} to itself (we'll see how it's
  done when we talk about fixed points).

  Show that \texttt{PreList} is an instance of \texttt{Bifunctor}.
\item
  Show that the following data types define bifunctors in \texttt{a} and
  \texttt{b}:

\begin{verbatim}
data K2 c a b = K2 c
\end{verbatim}

\begin{verbatim}
data Fst a b = Fst a
\end{verbatim}

\begin{verbatim}
data Snd a b = Snd b
\end{verbatim}

  For additional credit, check your solutions agains Conor McBride's
  paper \href{http://strictlypositive.org/CJ.pdf}{Clowns to the Left of
  me, Jokers to the Right}.
\item
  Define a bifunctor in a language other than Haskell. Implement
  \texttt{bimap} for a generic pair in that language.
\item
  Should \texttt{std::map} be considered a bifunctor or a profunctor in
  the two template arguments \texttt{Key} and \texttt{T}? How would you
  redesign this data type to make it so?
\end{enumerate}

Next:
\href{https://bartoszmilewski.com/2015/03/13/function-types/}{Function
Types}.

\subsection{Acknowledgment}\label{acknowledgment}

As usual, big thanks go to Gershom Bazerman for reviewing this
article.\\
\href{https://twitter.com/BartoszMilewski}{Follow @BartoszMilewski}
