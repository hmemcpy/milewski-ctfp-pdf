<div class="post-content"> <br><blockquote><p>This is part 16 of Categories for Programmers. Previously: <a href="https://bartoszmilewski.com/2015/09/01/the-yoneda-lemma/">The Yoneda Lemma</a>. See the <a href="https://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/">Table of Contents</a>.</p></blockquote>
<p>We&#x2019;ve seen previously that, when we fix an object <code>a</code> in the category <i>C</i>, the mapping <code>C(a, -)</code> is a (covariant) functor from <i>C</i> to <b>Set</b>.</p>
<pre>x -&gt; C(a, x)</pre>
<p>(The codomain is <b>Set</b> because the hom-set C(a, x) is a <em>set</em>.) We call this mapping a hom-functor &#x2014; we have previously defined its action on morphisms as well.</p>
<p>Now let&#x2019;s vary <code>a</code> in this mapping. We get a new mapping that assigns the hom-<em>functor</em> <code>C(a, -)</code> to any <code>a</code>.</p>
<pre>a -&gt; C(a, -)</pre>
<p>It&#x2019;s a mapping of objects from category <i>C</i> to functors, which are <em>objects</em> in the functor category (see the section about functor categories in <a href="https://bartoszmilewski.com/2015/04/07/natural-transformations/">Natural Transformations</a>). Let&#x2019;s use the notation <code>[C, Set]</code> for the functor category from <i>C</i> to <b>Set</b>. You may also recall that hom-functors are the prototypical <a href="https://bartoszmilewski.com/2015/07/29/representable-functors/">representable functors</a>.</p>
<p>Every time we have a mapping of objects between two categories, it&#x2019;s natural to ask if such a mapping is also a functor. In other words whether we can lift a morphism from one category to a morphism in the other category. A morphism in <i>C</i> is just an element of <code>C(a, b)</code>, but a morphism in the functor category <code>[C, Set]</code> is a natural transformation. So we are looking for a mapping of morphisms to natural transformations.</p>
<p>Let&#x2019;s see if we can find a natural transformation corresponding to a morphism <code>f :: a-&gt;b</code>. First, lets see what <code>a</code> and <code>b</code> are mapped to. They are mapped to two functors: <code>C(a, -)</code> and <code>C(b, -)</code>. We need a natural transformation between those two functors.</p>
<p>And here&#x2019;s the trick: we use the Yoneda lemma:</p>
<pre>[C, Set](C(a, -), F) &#x2245; F a</pre>
<p>and replace the generic <code>F</code> with the hom-functor <code>C(b, -)</code>. We get:</p>
<pre>[C, Set](C(a, -), C(b, -)) &#x2245; C(b, a)</pre>
<p><a href="https://bartoszmilewski.files.wordpress.com/2015/07/yoneda-embedding.jpg"><img class="alignnone wp-image-4782" src="https://bartoszmilewski.files.wordpress.com/2015/07/yoneda-embedding.jpg?w=372&amp;h=180%20372w,%20https://bartoszmilewski.files.wordpress.com/2015/07/yoneda-embedding.jpg?w=150&amp;h=72%20150w,%20https://bartoszmilewski.files.wordpress.com/2015/07/yoneda-embedding.jpg?w=300&amp;h=145%20300w,%20https://bartoszmilewski.files.wordpress.com/2015/07/yoneda-embedding.jpg%20721w" alt="Yoneda Embedding" width="372" srcset="https://bartoszmilewski.files.wordpress.com/2015/07/yoneda-embedding.jpg?w=372&amp;h=180 372w, https://bartoszmilewski.files.wordpress.com/2015/07/yoneda-embedding.jpg?w=150&amp;h=72 150w, https://bartoszmilewski.files.wordpress.com/2015/07/yoneda-embedding.jpg?w=300&amp;h=145 300w, https://bartoszmilewski.files.wordpress.com/2015/07/yoneda-embedding.jpg 721w"></a></p>
<p>This is exactly the natural transformation between the two hom-functors we were looking for, but with a little twist: We have a mapping between a natural transformation and a morphism &#x2014; an element of <code>C(b, a)</code> &#x2014; that goes in the &#x201C;wrong&#x201D; direction. But that&#x2019;s okay; it only means that the functor we are looking at is contravariant.</p>
<p><a href="https://bartoszmilewski.files.wordpress.com/2015/07/yoneda-embedding-2.jpg"><img class="alignnone wp-image-4783" src="https://bartoszmilewski.files.wordpress.com/2015/07/yoneda-embedding-2.jpg?w=431&amp;h=157%20431w,%20https://bartoszmilewski.files.wordpress.com/2015/07/yoneda-embedding-2.jpg?w=150&amp;h=55%20150w,%20https://bartoszmilewski.files.wordpress.com/2015/07/yoneda-embedding-2.jpg?w=300&amp;h=109%20300w,%20https://bartoszmilewski.files.wordpress.com/2015/07/yoneda-embedding-2.jpg?w=768&amp;h=280%20768w,%20https://bartoszmilewski.files.wordpress.com/2015/07/yoneda-embedding-2.jpg%20785w" alt="Yoneda Embedding 2" width="433" srcset="https://bartoszmilewski.files.wordpress.com/2015/07/yoneda-embedding-2.jpg?w=431&amp;h=157 431w, https://bartoszmilewski.files.wordpress.com/2015/07/yoneda-embedding-2.jpg?w=150&amp;h=55 150w, https://bartoszmilewski.files.wordpress.com/2015/07/yoneda-embedding-2.jpg?w=300&amp;h=109 300w, https://bartoszmilewski.files.wordpress.com/2015/07/yoneda-embedding-2.jpg?w=768&amp;h=280 768w, https://bartoszmilewski.files.wordpress.com/2015/07/yoneda-embedding-2.jpg 785w"></a></p>
<p>Actually, we&#x2019;ve got even more than we bargained for. The mapping from <i>C</i> to <code>[C, Set]</code> is not only a contravariant functor &#x2014; it is a <em>fully faithful</em> functor. Fullness and faithfulness are properties of functors that describe how they map hom-sets. </p>
<p>A <em>faithful</em> functor is <em>injective</em> on hom-sets, meaning that it maps distinct morphisms to distinct morphisms. In other words, it doesn&#x2019;t coalesce them. </p>
<p>A <em>full</em> functor is <em>surjective</em> on hom-sets, meaning that it maps one hom-set <em>onto</em> the other hom-set, fully covering the latter. </p>
<p>A fully faithful functor <code>F</code> is a <em>bijection</em> on hom-sets &#x2014; a one to one matching of all elements of both sets. For every pair of objects <code>a</code> and <code>b</code> in the source category <i>C</i> there is a bijection between <code>C(a, b)</code> and <code>D(F a, F b)</code>, where <i>D</i> is the target category of <code>F</code> (in our case, the functor category, <code>[C, Set]</code>). Notice that this doesn&#x2019;t mean that <code>F</code> is a bijection on <i>objects</i>. There may be objects in <i>D</i> that are not in the image of <code>F</code>, and we can&#x2019;t say anything about hom-sets for those objects.</p>
<h2>The Embedding</h2>
<p>The (contravariant) functor we have just described, the functor that maps objects in <i>C</i> to functors in <code>[C, Set]</code>:</p>
<pre>a -&gt; C(a, -)</pre>
<p>defines the <em>Yoneda embedding</em>. It <em>embeds</em> a category <i>C</i> (strictly speaking, the category <i>C<sup>op</sup></i>, because of contravariance) inside the functor category <code>[C, Set]</code>. It not only maps objects in <i>C</i> to functors, but also faithfully preserves all connections between them. </p>
<p>This is a very useful result because mathematicians know a lot about the category of functors, especially functors whose codomain is <b>Set</b>. We can get a lot of insight about an arbitrary category <i>C</i> by embedding it in the functor category.</p>
<p>Of course there is a dual version of the Yoneda embedding, sometimes called the co-Yoneda embedding. Observe that we could have started by fixing the target object (rather than the source object) of each hom-set, <code>C(-, a)</code>. That would give us a contravariant hom-functor. Contravariant functors from <i>C</i> to <b>Set</b> are our familiar presheaves (see, for instance, <a href="https://bartoszmilewski.com/2015/04/15/limits-and-colimits/">Limits and Colimits</a>). The co-Yoneda embedding defines the embedding of a category <i>C</i> in the category of presheaves. Its action on morphisms is given by:</p>
<pre>[C, Set](C(-, a), C(-, b)) &#x2245; C(a, b)</pre>
<p>Again, mathematicians know a lot about the category of presheaves, so being able to embed an arbitrary category in it is a big win.</p>
<h2>Application to Haskell</h2>
<p>In Haskell, the Yoneda embedding can be represented as the isomorphism between natural transformations amongst reader functors on the one hand, and functions (going in the opposite direction) on the other hand:</p>
<pre>forall x. (a -&gt; x) -&gt; (b -&gt; x) &#x2245; b -&gt; a</pre>
<p>(Remember, the reader functor is equivalent to <code>((-&gt;) a)</code>.)</p>
<p>The left hand side of this identity is a polymorphic function that, given a function from <code>a</code> to <code>x</code> and a value of type <code>b</code>, can produce a value of type <code>x</code> (I&#x2019;m uncurrying &#x2014; dropping the parentheses around &#x2014; the function <code>b -&gt; x</code>). The only way this can be done for all <code>x</code> is if our function knows how to convert a <code>b</code> to an <code>a</code>. It has to secretly have access to a function <code>b-&gt;a</code>. </p>
<p>Given such a converter, <code>btoa</code>, one can define the left hand side, call it<code>fromY</code>, as:</p>
<pre>fromY :: (a -&gt; x) -&gt; b -&gt; x fromY f b = f (btoa b)</pre>
<p>Conversely, given a function <code>fromY</code> we can recover the converter by calling <code>fromY</code> with the identity:</p>
<pre>fromY id :: b -&gt; a</pre>
<p>This establishes the bijection between functions of the type <code>fromY</code> and <code>btoa</code>.</p>
<p>An alternative way of looking at this isomorphism is that it&#x2019;s a CPS encoding of a function from <code>b</code> to <code>a</code>. The argument <code>a-&gt;x</code> is a continuation (the handler). The result is a function from <code>b</code> to <code>x</code> which, when called with a value of type <code>b</code>, will execute the continuation precomposed with the function being encoded. </p>
<p>The Yoneda embedding also explains some of the alternative representations of data structures in Haskell. In particular, it provides a very useful <a href="https://bartoszmilewski.com/2015/07/13/from-lenses-to-yoneda-embedding/">representation of lenses</a> from the <code>Control.Lens</code> library. </p>
<h2>Preorder Example</h2>
<p>This example was suggested by Robert Harper. It&#x2019;s the application of the Yoneda embedding to a category defined by a preorder. A preorder is a set with an ordering relation between its elements that&#x2019;s traditionally written as <code>&lt;=</code> (less than or equal). The &#x201C;pre&#x201D; in preorder is there because we&#x2019;re only requiring the relation to be transitive and reflexive but not necessarily antisymmetric (so it&#x2019;s possible to have cycles). </p>
<p>A set with the preorder relation gives rise to a category. The objects are the elements of this set. A morphism from object <code>a</code> to <code>b</code> either doesn&#x2019;t exist, if the objects cannot be compared or if it&#x2019;s not true that <code>a &lt;= b</code>; or it exists if <code>a &lt;= b</code>, and it points from <code>a</code> to <code>b</code>. There is never more than one morphism from one object to another. Therefore any hom-set in such a category is either an empty set or a one-element set. Such a category is called <em>thin</em>.</p>
<p>It&#x2019;s easy to convince yourself that this construction is indeed a category: The arrows are composable because, if <code>a &lt;= b</code> and <code>b &lt;= c</code> then <code>a &lt;= c</code>; and the composition is associative. We also have the identity arrows because every element is (less than or) equal to itself (reflexivity of the underlying relation). </p>
<p>We can now apply the co-Yoneda embedding to a preorder category. In particular, we&#x2019;re interested in its action on morphisms:</p>
<pre>[C, Set](C(-, a), C(-, b)) &#x2245; C(a, b)</pre>
<p>The hom-set on the right hand side is non-empty if and only if <code>a &lt;= b</code> &#x2014; in which case it&#x2019;s a one-element set. Consequently, if <code>a &lt;= b</code>, there exists a single natural transformation on the left. Otherwise there is no natural transformation.</p>
<p>So what&#x2019;s a natural transformation between hom-functors in a preorder? It should be a family of functions between sets <code>C(-, a)</code> and <code>C(-, b)</code>. In a preorder, each of these sets can either be empty or a singleton. Let&#x2019;s see what kind of functions are there at our disposal.</p>
<p>There is a function from an empty set to itself (the identity acting on an empty set), a function <code>absurd</code> from an empty set to a singleton set (it does nothing, since it only needs to be defined for elements of an empty set, of which there are none), and a function from a singleton to itself (the identity acting on a one-element set). The only combination that is forbidden is the mapping from a singleton to an empty set (what would the value of such a function be when acting on the single element?). </p>
<p>So our natural transformation will never connect a singleton hom-set to an empty hom-set. In other words, if <code>x &lt;= a</code> (singleton hom-set <code>C(x, a)</code>) then <code>C(x, b)</code> cannot be empty. A non-empty <code>C(x, b)</code> means that <code>x</code> is less or equal to <code>b</code>. So the existence of the natural transformation in question requires that, for every <code>x</code>, if <code>x &lt;= a</code> then <code>x &lt;= b</code>. </p>
<pre>for all x, x &#x2264; a &#x21D2; x &#x2264; b</pre>
<p>On the other hand, co-Yoneda tells us that the existence of this natural transformation is equivalent to <code>C(a, b)</code> being non-empty, or to <code>a &lt;= b</code>. Together, we get:</p>
<pre>a &#x2264; b if and only if for all x, x &#x2264; a &#x21D2; x &#x2264; b</pre>
<p>We could have arrived at this result directly. The intuition is that, if <code>a &lt;= b</code> then all elements that are below <code>a</code> must also be below <code>b</code>. Conversely, when you substitute <code>a</code> for <code>x</code> on the right hand side, it follows that <code>a &lt;= b</code>. But you must admit that arriving at this result through the Yoneda embedding is much more exciting.</p>
<h2>Naturality</h2>
<p>The Yoneda lemma establishes the isomorphism between the set of natural transformations and an object in <b>Set</b>. Natural transformations are morphisms in the functor category <code>[C, Set]</code>. The set of natural transformation between any two functors is a hom-set in that category. The Yoneda lemma is the isomorphism:</p>
<pre>[C, Set](C(a, -), F) &#x2245; F a</pre>
<p>This isomorphism turns out to be natural in both <code>F</code> and <code>a</code>. In other words, it&#x2019;s natural in <code>(F, a)</code>, a pair taken from the product category <code>[C, Set] &#xD7; C</code>. Notice that we are now treating <code>F</code> as an <em>object</em> in the functor category.</p>
<p>Let&#x2019;s think for a moment what this means. A natural isomorphism is an invertible <em>natural transformation</em> between two functors. And indeed, the right hand side of our isomorphism is a functor. It&#x2019;s a functor from <code>[C, Set] &#xD7; C</code> to <b>Set</b>. Its action on a pair <code>(F, a)</code> is a set &#x2014; the result of evaluating the functor <code>F</code> at the object <code>a</code>. This is called the evaluation functor.</p>
<p>The left hand side is also a functor that takes <code>(F, a)</code> to a set of natural transformations <code>[C, Set](C(a, -), F)</code>. </p>
<p>To show that these are really functors, we should also define their action on morphisms. But what&#x2019;s a morphism between a pair <code>(F, a)</code> and <code>(G, b)</code>? It&#x2019;s a pair of morphisms, <code>(&#x3A6;, f)</code>; the first being a morphism between functors &#x2014; a natural transformation &#x2014; the second being a regular morphism in <i>C</i>. </p>
<p>The evaluation functor takes this pair <code>(&#x3A6;, f)</code> and maps it to a function between two sets, <code>F a</code> and <code>G b</code>. We can easily construct such a function from the component of <code>&#x3A6;</code> at <code>a</code> (which maps <code>F a</code> to <code>G a</code>) and the morphism <code>f</code> lifted by <code>G</code>:</p>
<pre>(G f) &#x2218; &#x3A6;<sub>a</sub></pre>
<p>Notice that, because of naturality of <code>&#x3A6;</code>, this is the same as:</p>
<pre>&#x3A6;<sub>b</sub> &#x2218; (F f)</pre>
<p>I&#x2019;m not going to prove the naturality of the whole isomorphism &#x2014; after you&#x2019;ve established what the functors are, the proof is pretty mechanical. It follows from the fact that our isomorphism is built up from functors and natural transformations. There is simply no way for it to go wrong. </p>
<h2>Challenges</h2>
<ol>
<li>Express the co-Yoneda embedding in Haskell.</li>
<li>Show that the bijection we established between <code>fromY</code> and <code>btoa</code> is an isomorphism (the two mappings are the inverse of each other).</li>
<li>Work out the Yoneda embedding for a monoid. What functor corresponds to the monoid&#x2019;s single object? What natural transformations correspond to monoid morphisms?</li>
<li>What is the application of the <i>covariant</i> Yoneda embedding to preorders? (Question suggested by Gershom Bazerman.)</li>
<li>Yoneda embedding can be used to embed an arbitrary functor category <code>[C, D]</code> in the functor category <code>[[C, D], Set]</code>. Figure out how it works on morphisms (which in this case are natural transformations).</li>
</ol>
<p>Next: <a href="https://bartoszmilewski.com/2015/11/17/its-all-about-morphisms/">It&#x2019;s All About Morphisms</a>.</p>
<h2>Acknowledgments</h2>
<p>I&#x2019;d like to thank Gershom Bazerman for checking my math and logic.<br>
<a href="https://twitter.com/BartoszMilewski" class="twitter-follow-button">Follow @BartoszMilewski</a></p> </div>